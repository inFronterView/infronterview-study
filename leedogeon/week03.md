# 목차

- [JavaScript](#javascript)
  - [가비지 컬렉터란 무엇이며, 작동 원리에 대해 아는대로 최대한 자세히 설명해보세요.](#가비지-컬렉터란-무엇이며-작동-원리에-대해-아는대로-최대한-자세히-설명해보세요)
  - [메모리 누수란 무엇이며, 자바스크립트에서는 어떤 경우에 발생할 수 있을까요?](#메모리-누수란-무엇이며-자바스크립트에서는-어떤-경우에-발생할-수-있을까요)
  - [자바스크립트는 누가 언제 어디서 왜 만들었나요?](#자바스크립트는-누가-언제-어디서-왜-만들었나요)
  - [자바스크립트는 왜 싱글 스레드일까요?](#자바스크립트는-왜-싱글-스레드일까요)
  - [재귀함수의 장점과 단점은 어떤 것들이 있을까요?](#재귀함수의-장점과-단점은-어떤-것들이-있을까요)
  - [재귀 방식과 iterative 방식의 장단점은 무엇인가요?](#재귀-방식과-iterative-방식의-장단점은-무엇인가요)
- [React](#react)
  - [리덕스의 이름은 왜 리덕스일까요?](#리덕스의-이름은-왜-리덕스일까요)
  - [여러 개의 액션을 연속적으로 발생시키지 말아야 하는 이유는 무엇일까요? 명확한 이유와 예시를 이용해 설명해주세요.](#여러-개의-액션을-연속적으로-발생시키지-말아야-하는-이유는-무엇일까요-명확한-이유와-예시를-이용해-설명해주세요)
  - [Serialize 할 수 없는 값은 리덕스 상태에 왜 넣지 말라고 하는 것인가요? 명확한 이유와 함께 본인 만의 예시를 이용해 설명해주세요.](#serialize-할-수-없는-값은-리덕스-상태에-왜-넣지-말라고-하는-것인가요-명확한-이유와-함께-본인-만의-예시를-이용해-설명해주세요)
  - [상태 정규화란 무엇이고 왜 하는 것인가요? 명확한 이유와 함께 본인 만의 예시를 이용해 설명해주세요.](#상태-정규화란-무엇이고-왜-하는-것인가요-명확한-이유와-함께-본인-만의-예시를-이용해-설명해주세요)
  - [리덕스의 스토어는 내부적으로 어떻게 상태 변경을 감지할까요? 이와 비슷한 패턴을 가진 다른 예시는 무엇이 있을까요? 여러분은 이런 패턴을 어떤 경우에 적용해볼 수 있을까요?](#리덕스의-스토어는-내부적으로-어떻게-상태-변경을-감지할까요-이와-비슷한-패턴을-가진-다른-예시는-무엇이-있을까요-여러분은-이런-패턴을-어떤-경우에-적용해볼-수-있을까요)

<br><br>

# JavaScript

## 가비지 컬렉터란 무엇이며, 작동 원리에 대해 아는대로 최대한 자세히 설명해보세요.

가비지 컬렉터(Garbage Collector)는 프로그래밍 언어에서 메모리 관리를 자동화하는 기능입니다.<br>
JavaScript와 같은 언어에서는 개발자가 명시적으로 메모리를 해제할 필요 없이, 가비지 컬렉터가 사용하지 않는 메모리를 자동으로 회수해줍니다.

JavaScript의 가비지 컬렉터는 주로 Mark-and-Sweep 알고리즘을 사용합니다. 이 알고리즘은 도달 가능한 객체와 그렇지 않은 객체를 구분하여, 더 이상 참조되지 않는 객체(가비지)를 회수합니다.

Mark 단계: 프로그램의 루트(전역 객체나 스코프 내 변수 등)에서 도달 가능한 모든 객체를 "마킹"합니다.<br>
Sweep 단계: 마킹되지 않은 객체들을 메모리에서 해제하여 가비지로 처리합니다.<br>
이 외에도 참조 카운팅(reference counting)이라는 기법도 존재하지만, 순환 참조 문제가 있을 수 있어 JavaScript에서는 주로 Mark-and-Sweep 방식을 사용합니다.

<br>

## 메모리 누수란 무엇이며, 자바스크립트에서는 어떤 경우에 발생할 수 있을까요?

메모리 누수는 프로그램이 더 이상 필요하지 않은 메모리를 회수하지 못하고 계속 차지하고 있는 현상을 말합니다.<br>
JavaScript에서는 다음과 같은 상황에서 메모리 누수가 발생할 수 있습니다.

잘못된 클로저 사용: 클로저가 외부 변수를 계속 참조하고 있어, 그 변수가 메모리에서 해제되지 않는 경우.<br>
이벤트 리스너 누수: 등록한 이벤트 리스너를 제거하지 않으면, DOM 요소가 메모리에서 해제되지 않고 계속 남아 있게 됩니다.<br>
전역 변수 남용: 전역 변수는 프로그램이 종료될 때까지 메모리에서 해제되지 않기 때문에, 남용할 경우 메모리 누수가 발생할 수 있습니다.

<br>

## 자바스크립트는 누가 언제 어디서 왜 만들었나요?

JavaScript는 Brendan Eich가 1995년에 Netscape에서 개발했습니다.<br>
웹 페이지에 동적인 요소를 추가하기 위해 빠르게 개발된 언어로, 원래는 브라우저 내에서 간단한 상호작용을 가능하게 하기 위해 설계되었습니다.<br>
당시의 웹은 정적인 HTML로만 구성되어 있었기 때문에, JavaScript는 웹을 더 상호작용적으로 만들기 위한 도구로서 매우 중요한 역할을 하게 되었습니다.

<br>

## 자바스크립트는 왜 싱글 스레드일까요?

그 이유는 주로 브라우저 환경에서의 안정성을 위해서입니다.<br>
브라우저에서 여러 스레드를 사용할 경우, 동시에 DOM을 조작할 때 발생할 수 있는 경쟁 상태(race condition)나 데드락(deadlock) 문제를 방지해야 했기 때문입니다.

JavaScript는 이벤트 루프를 이용해 싱글 스레드 환경에서도 비동기 작업을 효율적으로 처리합니다. 이 덕분에 비동기 작업이 많아도 UI가 멈추지 않고 원활하게 실행됩니다.

<br>

## 재귀함수의 장점과 단점은 어떤 것들이 있을까요?

재귀 함수의 장점 중 하나는 코드의 간결성입니다.<br>
재귀 함수는 반복적인 구조나 순환적인 문제를 처리하는 데 매우 적합하며, 이를 통해 복잡한 문제를 더 직관적이고 간단한 방식으로 표현할 수 있습니다.<br>
특히 분할 정복(Divide and Conquer)이나 백트래킹과 같은 알고리즘에서는 문제를 자연스럽게 재귀적으로 해결할 수 있습니다.<br>
이러한 알고리즘에서는 큰 문제를 더 작은 하위 문제로 나누어 처리하기 때문에, 재귀 함수는 코드의 가독성을 높이고 논리 구조를 명확하게 표현하는 데 유리합니다.

하지만 단점으로는 성능 문제를 들 수 있습니다. 재귀 함수는 호출이 중첩되면서 스택 메모리를 많이 사용하게 되며, 이로 인해 호출 스택이 너무 깊어지면 스택 오버플로우(Stack Overflow)가 발생할 수 있습니다. 또한 함수 호출이 중첩될 때마다 스택 프레임이 쌓이기 때문에 메모리 사용량이 점점 증가합니다. 이로 인해 성능이 저하될 수 있으며, 큰 입력 데이터나 깊은 재귀 구조에서는 메모리 문제를 일으킬 수 있습니다. 따라서 재귀 함수를 사용할 때는 이러한 성능상의 단점을 고려해야 합니다.

<br>

## 재귀 방식과 iterative 방식의 장단점은 무엇인가요?

재귀 방식의 장점은 코드가 간결하고 직관적이라는 점입니다. 특히 재귀는 문제를 자연스럽게 분해하고 해결하는 데 적합한 방식으로, 트리나 그래프 탐색과 같은 복잡한 구조를 더 명확하게 표현할 수 있습니다.<br>
이러한 문제에서는 재귀적 표현이 반복적인 방식을 사용하는 것보다 더 직관적이며, 알고리즘의 논리를 쉽게 이해하고 유지보수하기가 용이합니다.<br>
하지만 재귀의 단점으로는 재귀 깊이가 깊어질수록 스택 메모리가 계속해서 쌓이면서 성능과 메모리 부담이 커질 수 있다는 점입니다.<br>
매우 깊은 재귀 호출이 발생하는 경우 스택 오버플로우 위험이 있으며, 이는 프로그램의 비정상적인 종료를 초래할 수 있습니다.

반복(iterative) 방식의 장점은 메모리 효율성입니다. 반복적인 로직은 호출 스택을 사용하지 않기 때문에, 메모리 사용량이 상대적으로 적으며 스택 오버플로우의 위험이 없습니다. 메모리 제약이 있는 환경에서 유리한 방식입니다.<br>
하지만 단점으로는 반복적인 코드가 복잡해질 수 있다는 점이 있습니다.<br>
예를 들어, 트리나 그래프 탐색과 같은 복잡한 알고리즘에서는 반복적인 로직을 사용하면 코드가 더 길어지고 복잡해질 수 있으며, 논리 구조를 명확하게 파악하기 어렵게 만듭니다.

<br><br>

# React

## 리덕스의 이름은 왜 리덕스일까요?

리덕스(Redux)는 Reduce 함수에서 이름을 따왔습니다. 리덕스의 기본 아이디어는 여러 상태 변경을 리듀서(reducer) 함수를 통해 관리하는 방식입니다.<br>
상태를 순수 함수인 리듀서를 사용해 누적(accumulate)하는 개념이 리듀스 함수와 유사하기 때문에, 리덕스라는 이름이 붙었습니다.

<br>

## 여러 개의 액션을 연속적으로 발생시키지 말아야 하는 이유는 무엇일까요? 명확한 이유와 예시를 이용해 설명해주세요.

여러 개의 액션을 연속적으로 발생시키는 것은 상태를 예측 불가능하게 만들 수 있습니다.<br>
리덕스에서는 하나의 액션이 디스패치되면, 해당 액션이 처리된 후에야 상태가 업데이트됩니다. 그러나 여러 액션이 너무 빠르게 연속적으로 발생하면, 각 액션에 의해 상태가 어떻게 변화하는지 추적하기 어려워집니다.<br>
예를 들어, 여러 번의 INCREMENT 액션이 거의 동시에 디스패치되면 상태가 제대로 반영되지 않거나 예기치 않은 결과를 초래할 수 있습니다.

<br>

## Serialize 할 수 없는 값은 리덕스 상태에 왜 넣지 말라고 하는 것인가요? 명확한 이유와 함께 본인 만의 예시를 이용해 설명해주세요.

리덕스에서 상태는 순수한 객체여야 하며, 직렬화(Serialization)가 가능해야 합니다. 직렬화할 수 없는 값(함수나 DOM 요소 등)을 상태에 저장할 경우, 상태를 직렬화하여 로깅하거나 상태를 복원하는 등의 작업이 어려워집니다.<br>
예를 들어, 비동기 함수나 특정 객체가 상태에 저장되어 있으면, 디버깅이나 타임 트래블 디버거와 같은 기능이 제대로 작동하지 않을 수 있습니다. 따라서 상태는 직렬화할 수 있는 단순 데이터 구조로만 관리하는 것이 원칙입니다.

<br>

## 상태 정규화란 무엇이고 왜 하는 것인가요? 명확한 이유와 함께 본인 만의 예시를 이용해 설명해주세요.

상태 정규화는 중복된 데이터를 줄이고, 상태를 관리하기 쉽게 만들기 위한 기법입니다.<br>
정규화된 상태는 중복된 데이터 대신 참조를 사용해 상태를 저장하며, 상태 업데이트가 필요한 경우에도 참조만 수정하면 되기 때문에 데이터의 일관성을 유지할 수 있습니다.

예를 들어, 블로그 게시물 목록과 각 게시물의 상세 정보가 상태로 관리되는 경우, 동일한 게시물이 중복 저장되는 것을 피하기 위해 정규화된 상태는 게시물의 ID만 저장하고, 실제 데이터는 별도의 객체로 관리합니다. 이로 인해 데이터 중복을 줄이고 상태 업데이트를 쉽게 처리할 수 있습니다.

<br>

## 리덕스의 스토어는 내부적으로 어떻게 상태 변경을 감지할까요? 이와 비슷한 패턴을 가진 다른 예시는 무엇이 있을까요? 여러분은 이런 패턴을 어떤 경우에 적용해볼 수 있을까요?

리덕스의 스토어는 구독(subscribe) 메커니즘을 사용하여 상태 변경을 감지합니다.<br>
스토어가 상태를 업데이트할 때마다, 스토어에 구독된 모든 리스너들에게 상태 변경이 통지됩니다.<br>
각 리스너는 스토어의 subscribe() 메서드를 통해 스토어에 구독할 수 있으며, 상태가 변경될 때마다 리스너가 실행됩니다.

이 패턴은 관찰자 패턴(Observer Pattern)에 기반하며, 이와 비슷한 예로 이벤트 리스너나 데이터 바인딩 같은 패턴이 있습니다.<br>
예를 들어, 프론트엔드 프레임워크에서 데이터가 변경될 때 DOM이 자동으로 업데이트되는 방식도 유사한 원리입니다.
