# 목차
- [JavaScript](#javascript)
- [React](#react)

<br>

# JavaScript

## 1. `var`, `let`, `const`의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.

### 답변:

### 개념 정리
- **`var`**:
    - **스코프**: `var`는 함수 스코프를 가집니다. 즉, 함수 내부에서 선언된 `var` 변수는 함수 전체에서 유효합니다.<br>
    그러나 블록 스코프를 지원하지 않기 때문에, `if`, `for` 등의 블록 내에서 선언된 `var` 변수는 해당 블록 외부에서도 접근이 가능합니다.
    
    - **호이스팅**: `var`는 호이스팅(hoisting)에 의해 변수 선언이 코드의 최상위로 끌어올려집니다.<br>
    하지만 선언은 끌어올려지지만, 초기화는 해당 줄에서 이루어지므로 선언 전에 사용하려고 하면 `undefined`를 반환합니다.
    
    - **중복 선언 가능**: 같은 스코프 내에서 동일한 이름으로 변수를 중복 선언할 수 있습니다.
- **`let`**:
    - **스코프**: `let`은 블록 스코프를 가집니다. 블록 내에서 선언된 `let` 변수는 해당 블록 내에서만 유효합니다.

    - **호이스팅**: `let` 역시 호이스팅되지만, 초기화가 이루어지기 전에는 변수를 참조할 수 없으며, 이를 “일시적 사각지대(Temporal Dead Zone)“라고 합니다.

    - **중복 선언 불가**: 같은 스코프 내에서 동일한 이름으로 변수를 중복 선언할 수 없습니다.
- **`const`**:
    - **스코프**: `const`도 `let`과 마찬가지로 블록 스코프를 가집니다.

    - **호이스팅**: `const`는 호이스팅되지만, 초기화가 이루어지기 전에는 참조할 수 없습니다.
    - **상수 선언**: `const`로 선언된 변수는 상수(constant)로 간주되어, 초기화 이후에 값을 변경할 수 없습니다. 하지만 `const`로 선언된 객체나 배열의 내부 값은 변경할 수 있습니다.
    - **중복 선언 불가**: 동일한 스코프 내에서 중복 선언할 수 없습니다.
- **사용 컨벤션**:
    - **`var` 사용 지양**: 함수 스코프와 호이스팅 때문에, 예기치 않은 오류를 피하기 위해 `var`는 사용을 지양하는 것이 좋습니다.

    - **`let`**: 값이 변할 가능성이 있는 변수에는 `let`을 사용합니다.

    - **`const`**: 값을 변경할 필요가 없는 경우에는 `const`를 사용합니다.<br>
    이는 불변성을 보장하여 코드의 안정성을 높이고, 잠재적인 오류를 방지할 수 있습니다.

<br>

## 2. 자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?

### 답변:

### 개념 정리

- **스레드(Thread)**
  - 실제로 작업을 처리하는 물리적 장치 = **'코어'**
  - 스레드란 CPU의 코어가 처리할 수 있는 작업의 흐름.
  - CPU가 작업을 처리하는 가장 작은 단위.
  - 각 스레드는 독립적으로 실행된다.
  - 스레드가 많을 수록 코어는 다양한 작업을 보다 유연하게 처리할 수 있다.
- **JavaScript는 싱글 스레드**
  - 단일 스레드에서 실행되며, 한 번에 하나의 작업만 수행할 수 있다.
  - 동기적으로 코드를 실행함을 의미.
  - 비동기 작업은 이벤트 루프를 통해 처리.
- **브라우저**
  - 멀티 스레드.
  - JavaScript를 처리하는 메인 스레드 외에도, '렌더링 엔진', '이벤트 핸들링', '네트워크 요청 처리' 등을 담당하는 여러게의 스레드가 존재.

<br>

## 3. 자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?

### 답변:

### 개념 정리

- **고차 함수(Higher-Order Function)란?**
  - 하나 이상의 함수를 인자로 받거나, 함수를 반환하는 함수.
  -`map`, `filter`, `reduce` 등이 대표적인 고차 함수이다.
- 장점:
  - **코드 간결성**: 고차 함수를 사용하면 반복되는 로직을 줄이고, 코드의 가독성을 높일 수 있습니다.
  - **재사용성**: 함수를 인자로 받거나 반환하는 구조로, 코드의 재사용성을 높일 수 있습니다.
  - **함수형 프로그래밍 지원**: 고차 함수는 함수형 프로그래밍 패러다임을 따르며, 불변성과 선언형 코드 작성을 가능하게 합니다.
      - 가능하다는 것이지, 무조건 함수형 프로그래밍을 따르는 것은 아님.
      - **함수형 프로그래밍**: 함수를 중심으로하는 프로그래밍 패러다임. **순수 함수**와 **불변성**을 강조.
      - 상태 변경이나 `side Effect`를 최소화하려고 함.
  - **유연성**: 고차 함수를 사용하면 다양한 동작을 추상화할 수 있어, 코드의 유연성을 높일 수 있습니다.

<br>

## 4. 자바스크립트의 `try..catch`의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.

### 답변:

### 개념 정리

- **`try..catch` 작동 방식**:
    - **`try` 블록**: 에러가 발생할 가능성이 있는 코드를 `try` 블록 안에 작성합니다. 이 블록에서 에러가 발생하면 코드 실행이 중단되고, `catch` 블록으로 제어가 넘어갑니다.
    - **`catch` 블록**: 에러가 발생하면 이 블록에서 해당 에러를 처리합니다. `catch` 블록의 매개변수로 에러 객체를 받아, 에러 정보를 확인할 수 있습니다.
    - **`finally` 블록**(선택 사항): `finally` 블록은 에러 발생 여부와 상관없이 `try`와 `catch` 블록이 끝난 후에 실행됩니다. 리소스 정리나 종료 작업에 사용됩니다.
- **사용 시기**:
    - **에러 처리**: 예상치 못한 에러가 발생할 수 있는 코드에서 에러를 처리하고, 프로그램이 중단되지 않도록 하기 위해 사용합니다.
    - **API 호출**: 외부 API를 호출할 때 네트워크 오류나 서버 오류를 처리하기 위해 `try..catch`를 사용합니다.
    - **파일 처리**: 파일 읽기/쓰기 작업에서 파일이 없거나, 권한이 없는 경우를 처리하기 위해 사용합니다.

<br>

## 5. 프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.

### 답변:

### 개념 정리

- **프러미스(Promise)** 는 비동기 작업의 결과를 나타내는 자바스크립트 객체입니다.<br>
비동기 작업의 성공, 실패(resolve, reject)를 나타내고, 그에 따라 후속 작업을 처리할 수 있도록 합니다.
- **사용 이유**:
    - **비동기 작업의 관리**: 콜백 함수의 중첩(콜백 지옥)을 피하고, 비동기 작업을 더 직관적이고 관리하기 쉽게 만듭니다.

    - **상태 관리**: 프러미스는 세 가지 상태(대기, 이행, 거부)를 가집니다. 이를 통해 비동기 작업의 상태를 명확하게 관리할 수 있습니다.

    - **에러 처리**: 프러미스 체인에서 에러가 발생하면, `catch` 블록에서 일관되게 에러를 처리할 수 있습니다. 이는 콜백 함수에서 발생할 수 있는 에러를 관리하기 어려운 점을 개선한 것입니다.

    - **순차적 비동기 작업**: 여러 비동기 작업을 순차적으로 처리할 수 있으며, `then` 메서드를 사용하여 비동기 작업을 체인 형태로 연결할 수 있습니다.

    - **ES6 표준**: 프러미스는 자바스크립트의 ES6 표준으로 포함되어, 브라우저 호환성 및 코드 일관성이 보장됩니다.

<br>

## 6. 자바스크립트의 Strict Mode에 대해 설명해보세요.

### 답변:

### 개념 정리

- **Strict Mode**는 자바스크립트에서 좀 더 엄격한 오류 검사를 수행하는 모드입니다. 이 모드를 활성화하면, 잠재적인 에러를 미리 감지하고, 예기치 않은 동작을 방지할 수 있습니다.

- **특징**:
    - **암묵적 전역 변수 금지**: 변수 선언 없이 사용하는 경우 에러를 발생시킵니다.
    - **중복 파라미터 금지**: 함수 선언 시 같은 이름의 파라미터를 사용할 수 없습니다.
    - **`this`의 값이 `undefined`로 설정**: 함수가 엄격 모드에서 호출되면 `this`는 undefined로 설정됩니다. (비엄격 모드에서는 전역 객체를 가리킵니다.)
    - **에러가 발생하는 구문**: `delete` 연산자를 사용해 변수, 함수, 매개변수를 삭제하려 하면 에러가 발생합니다.
        
        ```jsx
        "use strict";
        
        var x = 10;
        
        delete x; // SyntaxError: Delete of an unqualified identifier in strict mode.
        ```
        
    - **비정상적인 할당 금지**: 읽기 전용 속성에 값을 할당하려고 하면 에러를 발생시킵니다.
- **사용 방법**:
    - **전역 적용**: 스크립트 파일의 최상단에 "use strict";를 추가하여 스크립트 전체에 적용할 수 있습니다.
    - **함수 단위 적용**: 특정 함수 내부에서만 엄격 모드를 적용하려면, 함수의 첫 번째 줄에 "use strict";를 추가합니다.

<br>

## 7. 렉시컬 환경과 렉시컬 스코프란 무엇인가요?

### 답변:

### 개념 정리

- **렉시컬 환경(Lexical Environment)**:
    - **정의**: 렉시컬 환경은 자바스크립트가 코드를 실행할 때 변수를 저장하고 참조하는 구조입니다. 변수의 식별자와 값이 쌍으로 저장되며, 함수의 실행 컨텍스트에서 중요한 역할을 합니다.
    - **구성**: 렉시컬 환경은 환경 레코드(Environment Record)와 외부 렉시컬 환경(Outer Lexical Environment Reference)으로 구성됩니다. 환경 레코드는 현재 블록 또는 함수의 변수와 상수를 저장하며, 외부 렉시컬 환경은 외부 스코프를 참조합니다.
- **렉시컬 스코프(Lexical Scope)**:
    - **정의**: 렉시컬 스코프는 함수가 선언된 위치에 따라 변수의 유효 범위(스코프)가 결정되는 것을 의미합니다. 자바스크립트는 렉시컬 스코프 규칙을 따르기 때문에, 함수가 어디서 호출되는지와 관계없이, 선언될 당시의 스코프를 기준으로 변수를 참조합니다.
    - **예**: 함수가 중첩된 경우, 내부 함수는 외부 함수의 스코프에 접근할 수 있지만, 외부 함수는 내부 함수의 스코프에 접근할 수 없습니다.

<br>

## 8. `0.1 + 0.2 === 0.3`는 왜 `false`인가요?

### 답변:

### 개념 정리

- **부동소수점 오차**:

- 자바스크립트는 숫자를 64비트 부동소수점(IEEE 754 표준)을 사용하여 표현합니다. 이로 인해, 소수점 이하의 숫자를 정확하게 표현하는 데 제한이 있으며, 작은 오차가 발생할 수 있습니다.

- `0.1`과 `0.2`는 이진수로 정확히 표현되지 않으며, 내부적으로 약간의 오차가 발생합니다. 따라서 `0.1 + 0.2`의 결과는 `0.30000000000000004`로, 정확히 `0.3`이 아니므로 `false`를 반환합니다.

- **해결 방법**:

- 소수점을 다룰 때는 오차를 고려하여, `toFixed` 메서드를 사용하거나, 일정 범위 내에서 값이 같은지를 확인하는 방법을 사용할 수 있습니다.

- 예를 들어, `Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON`과 같이 작성하여 비교할 수 있습니다.

<br>

# React

## 1. 리액트의 상태 끌어올리기는 어떤 단점이 있을까요?

### 답변:

### 개념 정리

- **상태 끌어올리기** 란?
  - 여러 컴포넌트가 동일한 데이터를 공유할 수 있도록 상태를 상위 컴포넌트로 이동시키는 방법

- 단점:
  - **복잡성 증가**: 더 많은 컴포넌트가 상태를 관리, 코드가 복잡해진다.<br>
  컴포넌트 트리가 깊어질 수록 상태 전달이 힘들어진다.
  - **재렌더링 성능 저하**: 상위 컴포넌트에서 상태 변경 시, 해당 상태를 사용하는 모든 하위 컴포넌트가 재렌더링되기 때문에 불필요한 렌더링이 발생할 수 있다. -> 성능 저하 야기.
  - **유연성 부족**: 상태를 너무 상위로 끌어올리는 경우, 컴포넌트 간 결합도가 높아질 수 있다.

<br>

## 2. 가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?

### 답변:

### 개념 정리

- **가상 DOM(Virtual DOM)**: 실제 DOM의 가벼운 사본을 메모리에 유지.
- 가상돔은 메모리에 존재하는 가벼운 JavaScript 객체.

- **장점**:
  - **효율적 업데이트**: 메모리에서 변경 사항을 계산하여, 필요한 부분만 업데이트 한다.

  - **프로그래밍 모델 단순화**: DOM을 직접 조작하지 않고도, 상태 변경에 따라 UI 업데이트가 가능, 코드 단순화, 유지보수가 쉬워짐.
- **단점**:
  - **메모리 사용량 증가**: 가상DOM을 메모리에 유지하기 때문에 메모리 사용량이 증가할 수 있다.

  - **추가 오버헤드**: 가상DOM과 Diffing을 통해 변경 사항을 적용하는 과정에서, 약간의 성능 오버헤드가 발생할 수 있다.

<br>

## 3. 리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.

### 답변:

### 개념 정리

- **Diffing Algorithm**
 - 순서
    1.	가상돔 생성: 컴포넌트가 처음 렌더링되면, 리액트는 해당 컴포넌트의 가상돔을 생성한다. 이 가상돔은 실제 DOM의 스냅샷과 같은 역할을 한다.
    2.	새로운 가상돔 생성: 상태나 props가 변경되면, 리액트는 새로운 가상돔을 생성한다. 이 가상돔은 변경된 상태를 반영한 새로운 UI 구조를 나타낸다.

    3.	두 가상돔 비교(Diffing): 이전 가상돔과 새로운 가상돔을 비교하여 차이점을 찾아낸다.<br>
    •	동일한 타입의 노드는 속성(attribute)과 자식 노드의 변화를 검사.
    •	타입이 다른 노드는 새로운 노드로 간주하고, 이전 노드를 제거한 후 새 노드를 삽입.
    4.	패칭(Patching): Diffing 과정에서 발견된 차이점을 실제 DOM에 반영한다. 리액트는 필요한 부분만 업데이트하여, 전체 DOM을 다시 그리는 비효율을 방지한다.

<br>

## 4. 리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?

### 답변:

### 개념 정리

- 상태 업데이트가 비동기로 실행되는 이유: 리액트의 내부 스케줄링에 따라 한 번에 여러 상태 업데이트를 처리하기 때문에.

- 이유:
	1. **성능 최적화**: 여러 상태 변경을 일괄적으로 처리하여 불필요한 렌더링을 줄이고 성능을 최적화합니다.

	2. **일관성 유지**: 비동기 업데이트는 컴포넌트의 상태가 일관성을 유지하도록 도와줍니다. 여러 상태 변경이 있을 때, 최종 결과만을 반영하도록 합니다.
	3. **React 18의 Concurrent 모드 지원**: 비동기 상태 업데이트는 React 18의 Concurrent 모드에서 비동기 렌더링을 지원하기 위한 기반이 됩니다. 이를 통해 더 부드러운 UI 업데이트와 높은 응답성을 제공할 수 있습니다.

  - Concurrent 모드란?
    - 리액트 18에서 도입된 새로운 기능
    - 리액트가 작업의 우선순위를 동적으로 조정하여 중요한 작업(예: 사용자 입력)에 빠르게 응답하고, 덜 중요한 작업(예: 비동기 데이터 로딩)은 나중에 처리할 수 있도록 합니다.

<br>

## 5. 리액트 컴포넌트 내부에서 모든 함수를 `useCallback`으로 감싸는 것이 좋을까요?

### 답변:

### 개념 정리

  - **사용이 적절한 경우**:
	  -	**자식 컴포넌트에 콜백을 전달할 때**: 콜백 함수가 자식 컴포넌트로 전달되고, 자식 컴포넌트가 해당 함수의 변경 여부에 따라 렌더링 여부를 결정할 때 `useCallback`을 사용하는 것이 유리하다.

	  - **의존성 관리가 쉬운 경우**: `useCallback`을 사용할 때, 의존성 배열을 적절히 관리할 수 있을 때 유용하다.

- **주의할 점**:
  - **메모이제이션 오버헤드**: `useCallback` 자체가 메모이제이션을 수행하기 때문에, 함수가 자주 변경되지 않거나, 컴포넌트가 자주 렌더링되지 않는다면 오히려 성능에 악영향을 줄 수 있다.

  - **코드 복잡성 증가**: 모든 함수를 `useCallback`으로 감싸면, 의존성 배열을 관리해야 하고 코드가 불필요하게 복잡해질 수 있다.

 - 메모이제이션의 기본 원리
    - 먼저 메모이제이션은 특정 연산의 결과를 캐시에 저장해두고, 동일한 입력에 대해 다시 연산할 필요 없이 캐시된 결과를 재사용하는 최적화 기법이다. useCallback 훅은 함수의 메모이제이션을 수행하는 리액트 훅이다. 이는 컴포넌트가 다시 렌더링될 때마다 새로운 함수가 생성되지 않도록 하고, 이전에 생성된 함수를 재사용하여 성능을 최적화한다.

- 메모이제이션 오버헤드란?

    - 메모이제이션 자체에도 비용(오버헤드)이 발생합니다. 이 비용은 메모이제이션을 관리하고 캐시를 유지하는 데 필요한 연산과 메모리 소비에서 발생한다.
    	1.	캐시 유지 비용: useCallback은 의존성 배열에 기반하여 함수의 참조를 저장하고 관리한다. 이 과정에서 메모리를 사용하게 되며, 캐시 관리에 소모되는 자원도 있다.<br>
       즉, 매 렌더링 시, 리액트는 의존성 배열을 평가하고, 필요한 경우 캐시된 값을 갱신해야 한다. 이러한 과정이 빈번하게 발생하면, 이 자체가 성능에 영향을 줄 수 있다.

      2.	불필요한 메모이제이션: 함수가 자주 변경되지 않거나, 해당 컴포넌트가 자주 렌더링되지 않는 경우에도 useCallback을 적용하면 오히려 성능에 악영향을 줄 수 있다.<br>
       예를 들어, 함수가 거의 변하지 않는다면, 매 렌더링마다 굳이 메모이제이션을 유지할 필요가 없다. 이런 상황에서는 메모이제이션을 위한 추가적인 연산과 메모리 관리가 불필요하게 발생하게 된다.
      3.	참조 비교 비용: useCallback이 반환하는 함수는 메모이제이션된 상태이므로, 리액트는 이를 매 렌더링 시마다 비교하여 이전과 동일한지 확인한다. 이 비교 작업은 적은 비용이지만, 무분별하게 사용되면 이 또한 성능에 부담을 줄 수 있다.

