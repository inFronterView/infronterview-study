# 목차
- JavaScript
  - [**var, let, const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.**](#varletconst의-차이점-그리고-사용-컨벤션에-대해-최대한-자세히-설명해보세요)
  - [**자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?**](#자바스크립트는-싱글-스레드라고-합니다-스레드란-무엇인가요-브라우저도-싱글-스레드일까요)
  - [**자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?**](#자바스크립트에는-다양한-고차함수-형식의-메소드가-있습니다-고차함수의-장점은-무엇일까요)
  - [**자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.**](#자바스크립트의-trycatch의-기본적인-작동방식-그리고-언제-어떤-경우에-사용해야-하는지-조사해보세요)
  - [**프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.**](#프러미스를-사용하는-이유는-무엇인지-최대한-자세히-설명해보세요)
  - [**자바스크립트의 Strict Mode에 대해 설명해보세요.**](#자바스크립트의-strict-mode에-대해-설명해보세요)
  - [**렉시컬 환경과 렉시컬 스코프란 무엇인가요?**](#렉시컬-환경과-렉시컬-스코프란-무엇인가요)
  - [**0.1 + 0.2 === 0.3는 왜 false인가요?**](#010203는-왜false인가요)
- React
  - [**리액트의 상태 끌어올리기는 어떤 단점이 있을까요?**](#리액트의-상태-끌어올리기는-어떤-단점이-있을까요)
  - [**가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?**](#가상돔이라는-존재는-무엇이며-장점과-단점은-어떤-것들이-있을까요)
  - [**리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.**](#리액트의-diffing-algorithm의-내부-로직에-대해서-최대한-자세히-설명해보세요)
  - [**리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?**](#리액트의-상태-업데이트는-비동기로-실행됩니다-이-말은-무슨-뜻이며-왜-그럴까요)
  - [**리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?**](#리액트-컴포넌트-내부에서-모든-함수를usecallback으로-감싸는-것이-좋을까요)

<br>

# JavaScript

## var, let, const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.

먼저 var는 ES6 이전부터 사용되던 변수 선언 키워드입니다. 함수 스코프 또는 전역 스코프를 가지며, 호이스팅이 발생합니다. 이는 변수 선언이 스코프의 최상단으로 끌어올려지는 현상을 말합니다. 이로 인해 예측하기 어려운 동작을 할 수 있어 현대 JavaScript에서는 사용을 지양하고 있습니다.
ES6에서 도입된 let과 const는 블록 스코프를 가집니다. 이는 변수의 생명주기를 더 정확히 제어할 수 있게 해줍니다. 여기서 중요한 개념이 TDZ, 즉 Temporal Dead Zone입니다. 이는 스코프의 시작 지점부터 변수의 선언 시점까지의 구간을 의미합니다. let과 const로 선언된 변수는 선언 이전에 접근하려고 하면 ReferenceError가 발생합니다. TDZ는 코드의 안정성을 높이고, 변수 사용의 논리적 흐름을 강제합니다.
let은 재할당이 가능하지만 재선언은 불가능합니다. 주로 루프의 카운터 변수나 값이 변경되어야 하는 경우에 사용합니다. const는 재선언과 재할당 모두 불가능합니다. 단, 객체나 배열의 내부 속성은 변경 가능하다는 점을 유의해야 합니다. const는 불변성을 강조하고 개발자의 의도를 명확히 전달할 수 있어, 기본적인 변수 선언에 사용하는 것이 좋습니다.
사용 컨벤션으로는, 기본적으로 모든 변수에 const를 사용하고, 재할당이 필요한 경우에만 let을 사용하는 것이 권장됩니다. 이는 코드의 예측 가능성을 높이고 잠재적인 버그를 줄이는 데 도움이 됩니다.
let과 const의 도입, 특히 TDZ의 개념은 클로저 사용을 더 직관적으로 만들었습니다. 특히 비동기 작업에서 예측 가능한 결과를 얻기 쉬워졌고, 변수의 스코프를 명확히 하여 코드의 안정성을 크게 향상시켰습니다.

### 🧐 관련해서 알아두면 좋을 것들

<details>
<summary>
  <b>Temporal Dead Zone (TDZ)</b>
</summary>
<br/>

TDZ는 **스코프의 시작 지점부터 변수의 선언 시점까지의 구간**을 말합니다. 이 구간에서 해당 변수에 접근하려고 하면 ReferenceError가 발생합니다.

1. 스코프 진입: 변수가 선언된 스코프에 코드 실행이 진입합니다.
2. TDZ 시작: 이 시점부터 변수의 TDZ가 시작됩니다. 변수는 이미 선언되었지만, 아직 초기화되지 않은 상태입니다.
3. 변수 선언문 도달: 코드 실행이 변수의 선언문에 도달합니다.
4. TDZ 종료 및 초기화: 이 시점에서 변수가 초기화되고 TDZ가 종료됩니다. 이제 변수를 안전하게 사용할 수 있습니다.

TDZ는 let과 const로 선언된 변수에만 적용되며, 변수를 선언 전에 사용하는 실수를 방지하고 코드의 예측 가능성을 높이는 것이 주요 목적입니다. 특히 const로 선언된 변수가 반드시 초기값을 갖도록 보장하며, 이를 통해 코드의 안정성을 증가시키고 잠재적 버그를 줄입니다.

</details>

<details>
<summary>
  <b>Scope (스코프)</b>
</summary>
<br/>

JavaScript에서 스코프는 코드 내의 변수와 함수의 접근성을 결정하는 규칙입니다. 이는 변수나 함수가 어디서 유효하고 어디서 사용할 수 있는지를 정의합니다. 전역 스코프는 코드 어디에서나 접근 가능한 범위를 말하며, 함수 스코프는 특정 함수 내에서만 접근할 수 있는 범위를 의미합니다. ES6에서 도입된 블록 스코프는 중괄호로 둘러싸인 영역 내에서만 유효한 범위를 나타냅니다. 스코프는 코드의 구조화와 변수 관리에 중요한 역할을 하며, 변수 충돌을 방지하고 코드의 가독성과 유지보수성을 향상시킵니다. 또한 클로저와 같은 고급 JavaScript 기능의 기반이 되어, 더 효율적이고 강력한 프로그래밍을 가능하게 합니다.

</details>

<details>
<summary>
  <b>Closure (클로저)</b>
</summary>
<br/>

클로저(Closure)는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. 간단히 말해, 클로저는 함수가 자신이 생성될 때의 환경(스코프)을 기억하고 있다가, 나중에 그 환경 밖에서 호출되어도 그 환경에 접근할 수 있게 해주는 기능입니다.

> 🥸 <br> _클로저라는 개념은 사실 제가 공부하면서 클로저를 한마디로 정리하기가 어렵더라구요. 그래서 조금 더 깊이 파면서 공부해봤던 것 같습니다. 제가 공부했을 때 클로저를 한마디로 정리하자면 **클로저는 렉시컬 환경을 기억하는 것**이라 생각합니다. 예를 들어, 자바스크립트는 **함수가 일급 객체**로 취급되는데요. 일급 객체를 만족하는 특성 중 하나가 바로 반환값으로 사용될 수 있는 지인데, 함수의 실행 컨텍스트가 종료된 이후에도 해당 함수의 내부 자원을 참조하고 있는 함수가 있다면 해당 내부 자원에 접근 할 수 있게 됩니다._ <br><br>
> _클로저가 발생하는 이유는 **가비지 컬렉터의 동작방식 때문**이기도 한데요. 만약, 어떤 함수에서 외부 환경의 자원을 참조하고 있다면 그 자원은 실행 컨텍스트가 종료된 이후에도 가비지 컬렉터의 수집 대상에서 제외됩니다. 가비지 컬렉팅은 **Mark-Sweep-Compact 알고리즘**과 **Tri-color 알고리즘**을 사용하는데요. 마킹, 스위핑, 압축 단계로 진행됩니다. 마킹 단계에서는 가비지컬렉터는 객체들을 DFS로 순회하며, 객체들을 white, gray, black, 3가지 컬러로 마킹을 합니다. 마킹 단계 이후 스위핑 단계로 들어가서 여전히 흰색으로 마킹된 객체들의 메모리 주소를 free-list라고 부르는 자료 구조에 추가하여 메모리를 해제하게 됩니다._

</details>

<br>

## 자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?

스레드란 프로그램 내에서 실행되는 독립적인 작업 단위입니다. 한 프로세스 내에서 여러 스레드가 동시에 실행될 수 있으며, 각 스레드는 같은 프로세스의 메모리 공간을 공유합니다. 스레드를 사용하면 여러 작업을 동시에 처리할 수 있어 프로그램의 성능을 향상시킬 수 있습니다.

자바스크립트는 기본적으로 싱글 스레드로 동작합니다. 이는 한 번에 하나의 작업만을 수행할 수 있다는 의미입니다. 자바스크립트 엔진은 하나의 콜 스택을 가지고 있어, 코드를 순차적으로 실행합니다. 이러한 특성은 코드의 실행 순서를 예측하기 쉽게 만들지만, 동시에 긴 작업이 전체 프로그램을 블로킹할 수 있다는 단점도 있습니다.

그러나 브라우저는 자바스크립트 엔진 외에도 여러 요소로 구성되어 있어, 전체적으로는 멀티 스레드로 동작한다고 볼 수 있습니다. 브라우저의 주요 구성 요소들은 다음과 같습니다:

1. 자바스크립트 엔진: V8(Chrome), SpiderMonkey(Firefox) 등이 있으며, 자바스크립트 코드를 실행합니다. 이는 싱글 스레드로 동작합니다.
2. 렌더링 엔진: HTML과 CSS를 파싱하고 화면에 렌더링합니다. 이는 별도의 스레드에서 동작합니다.
3. Web API: DOM, AJAX, setTimeout 등의 API를 제공합니다. 이들은 브라우저에 의해 멀티 스레드로 관리됩니다.
4. 이벤트 루프: 비동기 작업의 완료를 감지하고, 콜백을 실행 큐에 추가합니다.
5. 태스크 큐: 비동기 작업의 콜백을 저장하는 큐입니다.

브라우저의 이러한 구조는 자바스크립트의 싱글 스레드 특성을 보완합니다. 예를 들어, 네트워크 요청이나 타이머 같은 비동기 작업은 Web API에 의해 처리되어 자바스크립트의 메인 스레드를 블로킹하지 않습니다. 작업이 완료되면 콜백이 태스크 큐에 추가되고, 이벤트 루프가 이를 감지하여 자바스크립트 엔진의 콜 스택이 비었을 때 실행합니다.

이러한 구조 덕분에 **자바스크립트는 싱글 스레드임에도 불구하고 비동기 프로그래밍이 가능하며, 브라우저는 여러 작업을 동시에 효율적으로 처리할 수 있습니다.** 예를 들어, 사용자 인터페이스 응답성을 유지하면서 동시에 네트워크 요청을 처리하고 애니메이션을 실행할 수 있습니다.

결론적으로, 자바스크립트 자체는 싱글 스레드이지만, 브라우저 환경은 멀티 스레드로 동작하여 효율적인 웹 애플리케이션 실행을 가능하게 합니다. 이 구조를 이해하는 것은 효율적인 웹 애플리케이션 개발과 성능 최적화에 매우 중요합니다.

<br>

## 자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?

고차 함수(Higher-Order Functions)는 함수를 인자로 받거나 함수를 반환하는 함수를 말합니다. <br>자바스크립트에서 함수는 일급 객체이기 때문에 이러한 고차 함수의 구현이 가능합니다. map(), filter(), reduce() 등이 대표적인 고차 함수의 예입니다.<br>
고차 함수의 장점은 코드의 추상화와 재사용성을 높인다는 점입니다. 복잡한 로직을 간결하고 가독성 있게 표현할 수 있어, 개발자가 핵심 비즈니스 로직에 집중할 수 있게 해줍니다. <br>
또한, 선언적 프로그래밍 방식을 통해 코드의 의도를 명확히 드러내며, 이는 유지보수성을 크게 향상시킵니다. 작은 함수들을 조합하여 복잡한 동작을 구현할 수 있는 유연성도 제공하여, 코드의 모듈화와 테스트 용이성을 증진시킵니다.<br>
결과적으로, 고차 함수는 더 효율적이고 견고한 프로그래밍을 가능하게 하여 전반적인 코드 품질을 높이는 데 기여합니다.

<br>

## 자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.

자바스크립트의 try..catch..finally 구문은 코드 실행 중 발생할 수 있는 예외를 처리하는 메커니즘입니다. try 블록에는 실행하고자 하는 코드를, catch 블록에는 에러 발생 시 처리할 로직을 작성합니다. 여기에 finally 블록을 추가할 수 있는데, 이 블록은 try나 catch 블록의 실행 결과와 관계없이 항상 실행되는 코드를 포함합니다. finally 블록은 리소스 해제나 정리 작업 등에 유용하게 사용됩니다.
이 구문은 주로 외부 리소스 접근, 사용자 입력 처리, JSON 파싱, 비동기 작업 등 에러가 발생할 가능성이 있는 상황에서 사용됩니다. try..catch..finally를 적절히 사용하면 프로그램의 안정성을 높이고 예상치 못한 상황에서도 우아하게 대처할 수 있습니다. 다만, 모든 코드를 이 구문으로 감싸는 것은 지양해야 하며, 에러가 발생할 가능성이 있는 특정 부분만을 대상으로 사용하는 것이 좋습니다.
catch 블록에서는 단순히 에러를 잡는 것에 그치지 않고, 적절한 에러 로깅이나 사용자 피드백 제공 등의 후속 처리를 해주는 것이 중요합니다. finally 블록은 에러 발생 여부와 관계없이 실행되어야 하는 코드, 예를 들어 데이터베이스 연결 종료나 파일 닫기 등의 작업에 사용됩니다. 이렇게 try..catch..finally를 효과적으로 활용하면 코드의 견고성을 높이고 사용자 경험을 개선할 수 있으며, 리소스 관리를 더욱 안전하게 할 수 있습니다.

<br>

## 프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.

프로미스는 자바스크립트에서 비동기 작업을 처리하는 객체입니다. 전통적인 콜백 방식의 단점을 극복하기 위해 도입되었으며, 비동기 로직을 더 구조화된 방식으로 작성할 수 있게 해줍니다. 프로미스는 비동기 작업의 상태(Pending, Fullfilled, Rejected)를 명확히 표현하여, 코드의 실행 흐름을 예측하기 쉽게 만듭니다. <br>
프로미스의 체이닝 기능은 여러 비동기 작업을 연속적으로 처리할 때 발생하는 콜백 중첩 문제를 해결합니다. 이를 통해 코드의 구조가 더 선형적이고 이해하기 쉬워집니다. 또한, 프로미스는 catch 메서드를 통해 에러 처리를 일관되게 할 수 있게 해주어, 비동기 코드의 안정성을 높입니다. <br>
Promise.all과 같은 메서드를 사용하면 여러 비동기 작업을 효율적으로 병렬 처리할 수 있어, 성능 최적화에 도움이 됩니다. 프로미스는 ECMAScript 6에서 표준화되어 다양한 환경에서 일관되게 사용할 수 있으며, async/await 문법의 기반이 되어 비동기 코드를 더욱 동기적으로 표현할 수 있게 해줍니다.
프로미스는 비동기 작업의 완료 시점을 정확히 캐치할 수 있게 해주어, 타이밍 관련 버그를 줄이는 데 도움을 줍니다.

<br>

## 자바스크립트의 Strict Mode에 대해 설명해보세요.

자바스크립트의 Strict Mode는 ECMAScript 5(2009)에서 도입된 기능으로, **코드를 더 엄격한 규칙 하에서 실행하도록 하는 옵션**입니다. 이 모드는 "use strict"; 지시어를 사용하여 활성화할 수 있으며, 스크립트 또는 함수의 최상단에 위치시킵니다. Strict Mode의 주요 목적은 일반적인 코딩 실수를 잡아내고, 안전하지 않은 동작을 방지하여 코드의 안정성을 높이는 것입니다. <br>
Strict Mode가 활성화되면 여러 가지 변화가 생깁니다. 먼저, 선언되지 않은 변수를 사용하려고 하면 에러가 발생합니다. 이는 변수의 스코프를 명확히 하고 전역 객체의 오염을 방지합니다. 또한, 삭제할 수 없는 속성을 삭제하려고 할 때나 읽기 전용 속성에 쓰기를 시도할 때도 에러가 발생합니다. 이는 객체의 무결성을 유지하는 데 도움이 됩니다. <br>
함수와 관련해서도 Strict Mode는 여러 제한을 둡니다. 함수 매개변수의 이름이 중복되는 것을 허용하지 않으며, with 문의 사용을 금지합니다. 또한, this의 동작도 변경되어 함수를 일반 호출할 때 this가 undefined로 바인딩됩니다. 이는 예기치 않은 전역 객체 수정을 방지합니다. <br>
Strict Mode는 몇 가지 문법적 제한도 추가합니다. 8진수 리터럴의 사용을 금지하고, eval과 arguments를 변수명이나 함수명으로 사용할 수 없게 합니다. 또한, arguments 객체의 동작도 변경되어 함수 내에서 arguments와 매개변수 간의 동기화가 이루어지지 않습니다. <br>
이러한 제한들은 일견 불편해 보일 수 있지만, 실제로는 코드의 품질과 안정성을 크게 향상시킵니다. 잠재적인 버그를 조기에 발견할 수 있게 해주며, 최적화에도 도움을 줍니다. <br>

그러나 Strict Mode 사용 시 주의할 점도 있습니다. 기존의 non-strict 코드와 함께 사용할 때 예기치 않은 동작이 발생할 수 있으므로, 점진적으로 도입하는 것이 좋습니다. 또한, 서드파티 라이브러리와의 호환성도 고려해야 합니다.

<br>

## 렉시컬 환경과 렉시컬 스코프란 무엇인가요?

렉시컬 환경과 렉시컬 스코프는 자바스크립트에서 변수의 접근성과 생명주기를 결정하는 중요한 개념입니다. <br>
렉시컬 환경은 특정 코드 블록이나 함수가 실행될 때 생성되는 내부 데이터 구조로, 해당 스코프 내의 식별자(변수명, 함수명 등)와 그 식별자에 바인딩된 값들의 맵핑을 저장합니다. 이 환경은 외부 렉시컬 환경에 대한 참조도 포함하여, 중첩된 스코프 체인을 형성합니다. <br>
렉시컬 스코프는 코드가 작성된 위치에 따라 결정되는 변수의 참조 범위를 의미합니다. 이는 함수나 블록이 선언된 위치를 기준으로 상위 스코프를 결정하며, 이를 통해 내부 스코프에서 외부 스코프의 변수에 접근할 수 있게 됩니다. 렉시컬 스코프는 코드를 작성할 때 이미 결정되므로, '정적 스코프'라고도 불립니다. <br>
이 두 개념은 밀접하게 연관되어 있습니다. 렉시컬 환경은 렉시컬 스코프를 구현하는 메커니즘이라고 볼 수 있습니다. 함수가 호출될 때마다 새로운 렉시컬 환경이 생성되지만, 그 환경의 외부 환경 참조는 함수가 정의된 위치의 렉시컬 환경을 가리키게 됩니다. 이를 통해 클로저와 같은 고급 자바스크립트 패턴이 가능해집니다. <br>
렉시컬 스코프의 특성으로 인해, 내부 함수에서 외부 함수의 변수에 접근할 수 있지만 그 역은 불가능합니다.  <br>이는 코드의 예측 가능성을 높이고 변수의 캡슐화를 가능하게 합니다. 또한, 렉시컬 스코프는 성능 최적화에도 도움이 됩니다. 컴파일러나 인터프리터가 변수의 참조 관계를 코드 작성 시점에 파악할 수 있기 때문입니다.

<br>

## `0.1 + 0.2 === 0.3는` 왜 `false`인가요?

자바스크립트에서 0.1 + 0.2 === 0.3가 false를 반환하는 이유는 부동소수점 숫자의 표현 방식과 관련이 있습니다. <br>
컴퓨터는 내부적으로 이진법을 사용하여 숫자를 표현합니다. 정수는 이진법으로 정확히 표현할 수 있지만, 일부 소수는 이진법으로 정확히 표현하기 어렵습니다. 0.1과 0.2는 이진법으로 정확히 표현할 수 없는 숫자들입니다.
자바스크립트는 IEEE 754 표준의 배정밀도 부동소수점 형식을 사용하여 숫자를 저장합니다. 이 형식에서 0.1은 무한히 반복되는 이진 소수로 표현되며, 이를 64비트로 제한된 메모리에 저장하려면 반올림이 발생합니다. 0.2도 마찬가지입니다. <br>
결과적으로, 0.1과 0.2를 더했을 때 정확히 0.3이 되지 않고 아주 작은 오차가 발생합니다. <br>
실제로 0.1 + 0.2는 0.30000000000000004와 같은 값이 됩니다. 이 값은 0.3과 매우 가깝지만 정확히 같지는 않습니다.
이러한 현상은 자바스크립트에만 국한된 것이 아니라 IEEE 754 표준을 사용하는 대부분의 프로그래밍 언어에서 발생합니다. 이는 컴퓨터가 실수를 표현하는 방식의 근본적인 한계에서 비롯됩니다.

### 🧐 관련해서 알아두면 좋을 것들

<details>
<summary>
  <b>부동소수점</b>
</summary>
<br/>

부동소수점은 컴퓨터에서 실수를 표현하는 방식 중 하나입니다. 이 방식은 매우 크거나 작은 수를 효율적으로 표현할 수 있어 널리 사용됩니다.

부동소수점의 **'부동'은 소수점의 위치가 고정되어 있지 않고 움직일 수 있다**는 의미입니다. 이 방식은 숫자를 세 부분으로 나누어 표현합니다:

1. 부호(sign): 양수인지 음수인지를 나타냅니다.
2. 가수(mantissa): 실제 숫자의 값을 나타냅니다.
3. 지수(exponent): 소수점의 위치를 나타냅니다.

예를 들어, 123.45는 부동소수점으로 1.2345 × 10^2로 표현할 수 있습니다. 여기서 1.2345가 가수, 2가 지수입니다.

컴퓨터는 이진법을 사용하기 때문에, 실제로는 2의 거듭제곱을 사용하여 숫자를 표현합니다. 이 방식은 매우 큰 범위의 숫자를 표현할 수 있지만, 일부 십진 소수는 이진 부동소수점으로 정확히 표현할 수 없다는 한계가 있습니다.

이러한 특성 때문에 부동소수점 연산에서 작은 오차가 발생할 수 있으며, 이는 0.1 + 0.2가 정확히 0.3이 되지 않는 이유이기도 합니다.

</details>

<br><br>

# React

## 리액트의 상태 끌어올리기는 어떤 단점이 있을까요?

첫째, 상태를 상위 컴포넌트로 끌어올리면 해당 컴포넌트의 복잡성이 증가할 수 있습니다. 여러 하위 컴포넌트의 상태를 관리해야 하므로, 상위 컴포넌트의 로직이 복잡해지고 유지보수가 어려워질 수 있습니다.

둘째, 상태를 자주 변경해야 하는 경우, 상태가 위치한 상위 컴포넌트와 그 하위 컴포넌트들이 불필요하게 자주 리렌더링될 수 있습니다. 이는 성능 저하로 이어질 수 있습니다.

셋째, 프롭스 드릴링(Props Drilling) 문제가 발생할 수 있습니다. 상태와 그 상태를 변경하는 함수를 여러 단계의 하위 컴포넌트로 전달해야 할 때, 중간 컴포넌트들은 실제로 그 프롭스를 사용하지 않음에도 불구하고 전달만 하는 역할을 하게 됩니다.

넷째, 컴포넌트 간의 결합도가 높아질 수 있습니다. 상태를 공유하는 컴포넌트들이 서로 밀접하게 연결되어, 한 컴포넌트의 변경이 다른 컴포넌트에 영향을 미칠 수 있습니다.

다섯째, 애플리케이션의 규모가 커질수록 상태 관리가 복잡해질 수 있습니다. 많은 상태를 최상위 컴포넌트로 끌어올리면, 그 컴포넌트가 애플리케이션의 모든 상태를 관리하는 거대한 컴포넌트가 될 수 있습니다.

마지막으로, 컴포넌트의 재사용성이 감소할 수 있습니다. 상태가 상위 컴포넌트에 의존하게 되면, 해당 컴포넌트를 다른 맥락에서 재사용하기 어려워질 수 있습니다.

이러한 단점들 때문에, 큰 규모의 애플리케이션에서는 상태 끌어올리기만으로는 충분하지 않을 수 있으며, Context API나 Redux 같은 상태 관리 라이브러리를 사용하는 것이 더 효과적일 수 있습니다.

<br>

## 가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?

가상 DOM은 실제 DOM의 경량화된 복사본으로, 메모리 상에 존재하는 자바스크립트 객체입니다. 이는 UI의 이상적인 상태를 효율적으로 관리하고 실제 DOM과 동기화하는 메커니즘을 제공합니다. 가상 DOM의 핵심은 '재조정(Reconciliation)' 과정에 있습니다. 가상 돔은 변화를 감지하면 재조정(Reconcilation)과정을 통하여 실제 DOM과 동기화 합니다. 이 과정에서 차이점 비교 알고리즘(Diffing Algorithm)을 사용하여 이전 상태와 새로운 상태를 효율적으로 비교하고, 실제로 변경된 부분만을 식별합니다. <br>
그러나 가상 DOM에도 단점이 있습니다. 가상 DOM에 대한 추가적인 메모리 사용은 대규모 애플리케이션에서 부담이 될 수 있으며, 가상 DOM 라이브러리의 초기 로딩 시간이 필요합니다. 또한, 간단한 UI나 정적 콘텐츠에서는 가상 DOM이 불필요한 복잡성을 추가할 수 있습니다. 더불어, 가상 DOM의 추상화 레이어로 인해 때로는 세밀한 DOM 최적화가 어려울 수 있습니다.

<br>

## 리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.

리액트의 Diffing Algorithm은 가상 DOM의 효율적인 업데이트를 위한 핵심 메커니즘입니다. 이 알고리즘은 두 개의 트리를 비교하여 변경된 부분을 식별하고, 최소한의 DOM 조작으로 실제 DOM을 업데이트합니다.

알고리즘의 첫 단계는 루트 엘리먼트부터 시작합니다. 루트 엘리먼트의 타입이 변경된 경우, 리액트는 이전 트리를 완전히 버리고 새로운 트리를 처음부터 구축합니다. 이는 기존의 모든 하위 엘리먼트들도 새로 생성됨을 의미합니다.

같은 타입의 DOM 엘리먼트를 비교할 때, 리액트는 두 엘리먼트의 속성을 검사하고 변경된 속성만 업데이트합니다. 이 과정에서 스타일이나 클래스 이름과 같은 복잡한 속성들도 효율적으로 처리됩니다.

컴포넌트 엘리먼트를 비교할 때는, 컴포넌트의 인스턴스가 유지되고 state가 보존됩니다. 리액트는 새로운 엘리먼트의 props로 해당 컴포넌트 인스턴스를 업데이트하고, componentDidUpdate 생명주기 메서드를 호출합니다.

자식 엘리먼트들을 재귀적으로 처리할 때, 리액트는 기본적으로 동시에 두 리스트를 순회하며 차이점을 생성합니다. 그러나 이 방식은 리스트의 순서가 변경되었을 때 비효율적일 수 있습니다. 이를 개선하기 위해 리액트는 'key' 속성을 사용합니다. 개발자가 자식 엘리먼트에 안정적이고 고유한 key를 제공하면, 리액트는 이를 사용하여 더 효율적으로 엘리먼트의 이동을 추적하고 재사용할 수 있습니다.

리액트의 Diffing Algorithm은 O(n) 복잡도를 가지도록 설계되었습니다. 이는 트리의 모든 엘리먼트를 한 번씩만 방문한다는 것을 의미합니다. 이러한 효율성은 두 가지 가정에 기반합니다: 서로 다른 타입의 두 엘리먼트는 다른 트리를 생성할 것이라는 점, 그리고 개발자가 key prop을 통해 여러 렌더링 사이에서 어떤 자식 엘리먼트가 안정적인지 표시할 수 있다는 점입니다.

이 알고리즘은 대부분의 실제 사용 사례에서 매우 효율적으로 작동하지만, 특정 상황에서는 최적화가 필요할 수 있습니다. 예를 들어, 엘리먼트의 순서가 자주 변경되는 경우 key를 사용하여 성능을 개선할 수 있습니다. 또한, shouldComponentUpdate 생명주기 메서드나 React.memo를 사용하여 불필요한 비교를 줄일 수 있습니다.

결론적으로, 리액트의 Diffing Algorithm은 복잡한 UI 업데이트를 효율적으로 처리하는 핵심 메커니즘입니다. 이 알고리즘의 이해는 리액트 애플리케이션의 성능 최적화에 중요한 역할을 합니다.

<br>

## 리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?

리액트에서 상태 업데이트가 비동기로 실행된다는 것은 상태를 변경하는 함수(setState 등)를 호출한 직후에 상태가 즉시 업데이트되지 않는다는 의미입니다. 대신, 리액트는 여러 상태 업데이트를 모아서 일괄 처리(batching)합니다. 이로 인해 상태 업데이트 함수 호출 직후에 새로운 상태 값을 참조하려고 하면, 아직 업데이트되지 않은 이전 값을 얻게 될 수 있습니다.

리액트가 이러한 방식을 채택한 이유는 여러 가지가 있습니다:

1. 성능 최적화: 여러 상태 업데이트를 한 번에 처리함으로써 불필요한 재렌더링을 줄이고 전반적인 애플리케이션 성능을 향상시킵니다.
2. 일관성 유지: 부모와 자식 컴포넌트의 상태가 동시에 업데이트될 때, 일괄 처리를 통해 일관된 UI 상태를 유지할 수 있습니다.
3. 불필요한 계산 방지: 여러 상태 업데이트가 연속적으로 발생할 때, 중간 상태에 대한 불필요한 계산과 렌더링을 방지합니다.
4. 구현의 유연성: 리액트 팀이 내부 구현을 최적화하고 개선할 수 있는 여지를 제공합니다.

이러한 비동기 업데이트 방식은 대부분의 상황에서 이점을 제공하지만, 때로는 즉시 업데이트된 상태가 필요할 수 있습니다. 이런 경우를 위해 리액트는 useEffect 훅이나 상태 업데이트 함수의 콜백 등을 제공하여 상태 업데이트 이후의 로직을 처리할 수 있게 합니다.

<br>

## 리액트 컴포넌트 내부에서 모든 함수를 `useCallback`으로 감싸는 것이 좋을까요?

useCallback은 메모이제이션된 콜백을 반환하는 훅으로, 의존성 배열이 변경되지 않는 한 동일한 함수 참조를 유지합니다. 이는 주로 불필요한 렌더링을 방지하고 성능을 최적화하는 데 사용됩니다. 그러나 무분별한 사용은 오히려 역효과를 낼 수 있습니다.

useCallback을 사용하는 것이 유용한 경우는 주로 다음과 같습니다:

1. 자식 컴포넌트에 콜백을 prop으로 전달할 때, 특히 그 자식 컴포넌트가 **React.memo로 최적화**되어 있는 경우
2. useEffect의 의존성 배열에 함수를 포함시켜야 할 때
3. 함수가 복잡한 연산을 포함하고 있고, 그 결과가 자주 변경되지 않을 때

반면, 모든 함수를 useCallback으로 감싸는 것의 단점은 다음과 같습니다:

1. 코드의 복잡성 증가: 과도한 useCallback 사용은 코드를 읽고 유지보수하기 어렵게 만들 수 있습니다.
2. 성능 오버헤드: useCallback 자체도 메모리와 계산 비용이 들기 때문에, 불필요한 경우 오히려 성능을 저하시킬 수 있습니다.
3. 의존성 배열 관리의 복잡성: 각 useCallback에 대한 의존성 배열을 정확히 관리해야 하며, 이는 오류의 원인이 될 수 있습니다.

따라서, useCallback의 사용은 실제 성능 측정을 통해 이점이 있다고 확인된 경우에 선택적으로 적용하는 것이 좋습니다. 대부분의 경우, 리액트의 기본 렌더링 최적화만으로도 충분히 효율적입니다. 특히 최신 브라우저와 디바이스에서는 함수를 새로 생성하는 비용이 그리 크지 않아, 불필요한 최적화로 인한 복잡성 증가가 더 큰 문제가 될 수 있습니다.

결론적으로, useCallback은 성능 최적화를 위한 도구이지만, 모든 상황에 적용해야 하는 규칙은 아닙니다. 컴포넌트의 특성, 렌더링 빈도, 전체 애플리케이션의 성능 등을 종합적으로 고려하여 필요한 경우에만 선택적으로 사용하는 것이 바람직합니다.

### 🧐 관련해서 알아두면 좋을 것들

<details>
<summary>
  <b>useCallback 사용 예시</b>
</summary>
<br/>

```js
import React from "react";

const ChildComponent = React.memo(({ onClick }) => {
  console.log("ChildComponent rendered");
  return <button onClick={onClick}>Click me</button>;
});

export default ChildComponent;
```

```js
import React, { useState, useCallback } from "react";
import ChildComponent from "./ChildComponent";

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const [otherState, setOtherState] = useState(0);

  // useCallback을 사용하지 않은 경우
  // const handleClick = () => {
  //   setCount(count + 1);
  // };

  // useCallback을 사용한 경우
  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []); // 의존성 배열이 비어있으므로 컴포넌트가 마운트될 때만 함수가 생성됩니다.

  const handleOtherClick = () => {
    setOtherState(otherState + 1);
  };

  console.log("ParentComponent rendered");

  return (
    <div>
      <p>Count: {count}</p>
      <p>Other State: {otherState}</p>
      <ChildComponent onClick={handleClick} />
      <button onClick={handleOtherClick}>Update Other State</button>
    </div>
  );
};

export default ParentComponent;
```

1. useCallback을 사용하지 않은 경우:
   - ParentComponent가 리렌더링될 때마다 (예: otherState가 변경될 때) 새로운 handleClick 함수가 생성됩니다.
   - 이로 인해 ChildComponent의 props가 변경되어, React.memo의 최적화에도 불구하고 ChildComponent가 불필요하게 리렌더링됩니다.
2. useCallback을 사용한 경우:
   - handleClick 함수는 컴포넌트가 마운트될 때 한 번만 생성되고, 이후 리렌더링에서는 동일한 함수 참조가 유지됩니다.
   - otherState가 변경되어 ParentComponent가 리렌더링되더라도, ChildComponent에 전달되는 onClick prop은 변경되지 않습니다.
   - 따라서 React.memo의 최적화가 효과적으로 작동하여, ChildComponent는 불필요하게 리렌더링되지 않습니다.

이 예제에서 useCallback을 사용하면, otherState가 변경될 때 ParentComponent는 리렌더링되지만 ChildComponent는 리렌더링되지 않습니다. 이는 특히 ChildComponent가 복잡하거나 렌더링 비용이 높은 경우에 성능 향상을 가져올 수 있습니다.

</details>
