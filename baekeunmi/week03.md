# 목차

- JavaScript
  - [가비지 컬렉터란 무엇이며, 작동 원리에 대해 아는대로 최대한 자세히 설명해보세요.](#가비지-컬렉터란-무엇이며-작동-원리에-대해-아는대로-최대한-자세히-설명해보세요)
  - [메모리 누수란 무엇이며, 자바스크립트에서는 어떤 경우에 발생할 수 있을까요?](#메모리-누수란-무엇이며-자바스크립트에서는-어떤-경우에-발생할-수-있을까요)
  - [자바스크립트는 누가 언제 어디서 왜 만들었나요?](#자바스크립트는-누가-언제-어디서-왜-만들었나요)
  - [자바스크립트는 왜 싱글 스레드일까요?](#자바스크립트는-왜-싱글-스레드일까요)
  - [재귀함수의 장점과 단점은 어떤 것들이 있을까요?](#재귀함수의-장점과-단점은-어떤-것들이-있을까요)
  - [재귀 방식과 iterative 방식의 장단점은 무엇인가요?](#재귀-방식과-iterative-방식의-장단점은-무엇인가요)
  - [제어 컴포넌트와 비제어 컴포넌트](#제어-컴포넌트와-비제어-컴포넌트)

<br>

# Javascript

## 가비지 컬렉터란 무엇이며, 작동 원리에 대해 아는대로 최대한 자세히 설명해보세요.

자바스크립트는 메모리를 자동으로 관리하는 가비지 컬렉터를 가지고 있습니다. 가비지 컬렉터는 메모리에 할당된 객체 중에서 더 이상 사용되지 않는 객체, 즉 Garbage(쓰레기)를 자동으로 탐지하고 제거하는 역할을 합니다.

V8 엔진에서는 크게 두 가지 방식의 가비지 컬렉션이 있습니다.

### 1. Young Generation

- 새로 생성된 객체들이 저장되는 공간입니다.
- Minor GC가 이 영역을 주로 청소합니다.
- Scavenge 알고리즘 사용
  - 두 개의 semi-space (From-space와 To-space)로 나누어 작동합니다.
  - 살아있는 객체를 To-space로 복사 후 From-space를 비움니다.
  - 복사 후 From-space와 To-space의 역할을 교체합니다.
- 살아남은 객체는 Old Generation으로 이동합니다.
  - 일정 횟수 이상 GC에서 살아남은 객체입니다.
  - To-space의 일정 비율 이상 차지하는 객체입니다.

### 2. Old Generation

- 오래 살아남은 객체들이 저장되는 공간입니다.
- Major GC가 이 영역을 주로 청소합니다.
- Mark-Sweep-Compact 알고리즘 사용

### Major GC 과정

1. **Mark 단계**

- GC 루트(전역 객체, 스택 등)에서 시작하여 모든 참조 가능한 객체를 탐색하며 마킹합니다.
- Tri-color 알고리즘 사용
  - White: 아직 검사하지 않은 객체입니다.
  - Gray: 검사는 했지만, 이 객체가 참조하는 다른 객체들을 아직 모두 검사하지 않은 상태입니다.
  - Black: 검사를 완료하고 참조하는 모든 객체도 검사한 객체입니다.
- 과정
  1. 모든 객체를 White로 초기화합니다.
  2. GC 루트를 Gray로 마킹합니다.
  3. 다음 과정을 Gray 객체가 더 이상 없을 때까지 반복합니다
  - Gray 객체 하나를 선택합니다.
  - 이 Gray 객체가 참조하는 모든 White 객체를 Gray로 마킹합니다.
  - 선택한 Gray 객체를 Black으로 마킹합니다.
  4. 모든 Gray 객체가 처리되면(즉, Gray 객체가 더 이상 없으면) 과정을 종료합니다.
  5. 남아있는 White 객체들은 가비지로 간주합니다.

2. **Sweep 단계**

- 마킹되지 않은 객체들(White)의 메모리를 해제합니다.
- Free List: 해제된 메모리 블록들을 관리하는 자료구조입니다.
  - 연속된 가용 메모리 블록들을 리스트 형태로 관리합니다.
  - 새로운 객체 할당 시 이 리스트에서 적절한 크기의 블록을 찾아 사용합니다.

3. **Compact 단계**

- 메모리 단편화를 줄이기 위해 살아있는 객체들을 연속된 메모리 공간으로 이동합니다.
- Mark-and-Sweep만으로는 메모리 단편화 문제가 발생합니다.
  - 작은 가용 메모리 조각들이 흩어져 있어 큰 객체 할당이 어려워집니다.
- Compaction 과정
  1. 살아있는 객체들을 메모리의 한쪽 끝으로 모읍니다.
  2. 객체들의 참조를 새 위치로 업데이트합니다.
  3. 남은 공간을 큰 가용 메모리 블록으로 확보합니다.

이러한 Minor GC와 Major GC의 가비지 컬렉션이 수행할 때 프로그램이 멈추게 됩니다. 이를 Stop-The-World (STW) 현상이라고 합니다. 이 시간이 길어질수록 페이지가 느려지거나 렌더링이 지연되어 사용자들은 UX 경험이 좋지 못합니다. 최적화를 위해 아래과 같은 방식이 추가되었습니다.

1. 병렬적(Parallel) GC

- 메인 스레드 혼자 하는 일들 헬퍼 스레드와 같이 여러 스레드를 사용하여 GC 작업을 동시에 수행합니다.
- 스레드 간의 동기화를 처리해야 해서 오버헤드는 생기지만 stop-the-world 시간이 크게 감소합니다.

2. 점진적(Incremental) GC

- 메인 스레드가 GC 작업을 여러 단계로 나누어 수행합니다. (GC 수행 → 스크립트 수행 → GC 수행 → 스크립트 수행 ...)
- 각 단계 사이에 애플리케이션 실행을 허용하여 일시 정지 시간을 분산시킵니다.

3. 동시적(Concurrent) GC

- GC 작업과 애플리케이션 실행을 동시에 수행합니다.메인 스레드는 GC 작업을 하지 않고, 헬퍼 스레드들이 수행합니다.
- STW 시간을 최소화하지만, 추가적인 CPU 오버헤드가 발생할 수 있습니다.

<br>

## 메모리 누수란 무엇이며, 자바스크립트에서는 어떤 경우에 발생할 수 있을까요?

메모리 누수(Memory Leak)는 프로그램이 더 이상 필요하지 않은 메모리를 계속 점유하고 있는 현상을 말합니다. 자바스크립트에서는 가비지 컬렉터가 자동으로 메모리를 관리하지만, 특정 상황에서는 메모리 누수가 발생할 수 있습니다.

### 자바스크립트에서 메모리 누수가 발생하는 주요 경우

1. **의도치않게 생성된 전역 변수**

- 전역 변수는 가비지 컬렉터의 수거 대상이 되지 않습니다.

  ```javascript
  function createGlobal() {
    globalVar = "전역변수 입니다.";
  }

  createGlobal();
  // globalVar는 함수 실행 후에도 계속 메모리를 차지합니다.
  ```

- strict 모드를 사용하게 되면 모르고 실수하는 것에 대해서 경고 에러를 받을 수 있습니다.

2. **해제 하지 않은 타이머**

- `setInterval`이나 `setTimeout`으로 생성된 타이머가 적절히 해제되지 않으면 메모리 누수의 원인이 됩니다.

  ```javascript
  const serverData = loadData();

  setInterval(function () {
    const renderer = document.getElementById("renderer");

    if (renderer) {
      renderer.innerHTML = JSON.stringify(serverData);
    }
  }, 5000); // 이 인터벌은 해제되지 않습니다.
  ```

- `setInterval`이나 `setTimeout`을 사용할 때는 `clearInterval`이나 `clearTimeout`으로 해제합니다.

3. **클로저의 부적절한 사용**

- 클로저가 외부 변수를 참조하면, 그 변수는 가비지 컬렉션의 대상이 되지 않습니다.

  ```javascript
  function outer() {
    const largeData = new Array(1000000);

    return function inner() {
      return largeData[0];
    };
  }

  const closure = outer(); // largeData 전체가 메모리에 유지됩니다.
  ```

4. **DOM 외부 참조**

- DOM 요소가 웹 페이지에서 사라져도, 자바스크립트가 그 요소를 "기억"하고 있으면 메모리에서 완전히 제거되지 않습니다.

  ```javascript
  const button = document.getElementById("button");

  button.addEventListener("click", () => {
    console.log("Button clicked");
  });

  function removeButton() {
    button.remove();
    console.log("Button removed from DOM");
    // 여기서 button 변수는 여전히 제거된 DOM 요소를 참조하고 있습니다.
  }

  removeButton();
  console.log(button); // 여전히 제거된 DOM 요소 참조합니다.
  ```

- 메모리 누수를 방지하기 위해 button에 null을 할당하여 참조를 제거해야합니다.

5. **콘솔에 객체 출력**

- 개발 도구 콘솔에 객체를 출력하면, 브라우저가 해당 객체에 대한 참조를 유지할 수 있습니다.

  ```javascript
  var largeObject = {
    // ... 많은 데이터 ...
  };
  console.log(largeObject);
  // 콘솔에 출력된 객체는 메모리에 계속 남아있을 수 있습니다.
  ```

<br>

## 자바스크립트는 누가 언제 어디서 왜 만들었나요?

자바스크립트는 1995년 브렌던 아이크(Brendan Eich)가 넷스케이프(Netscape)에서 웹 브라우저의 사용자 경험을 향상시키기 위해 개발했습니다. 당시 웹 페이지는 정적 콘텐츠 위주였으며, 이를 동적으로 만들기 위해 10일 만에 프로토타입이 완성되었습니다. 자바스크립트의 주요 목적은 웹 페이지에서 사용자 입력 검증, 동적 콘텐츠 생성, 브라우저 제어 등을 가능하게 하는 것이었습니다. 이는 서버와의 불필요한 통신을 줄이고 웹 페이지의 반응성을 높이는 데 크게 기여했습니다. "Java"라는 이름은 당시 인기 있던 자바 언어의 명성을 활용하기 위해 마케팅적으로 사용되었으나, 두 언어는 실제로 별개의 목적과 설계를 가지고 있습니다.

<br>

## 자바스크립트는 왜 싱글 스레드일까요?

- 단순성: 웹 브라우저에서 실행되는 스크립트 언어로 시작되었기 때문에, 복잡한 멀티스레딩 개념 없이 간단하게 설계되었습니다.
- DOM 조작의 안전성: 여러 스레드가 동시에 DOM을 조작하면 예측 불가능한 결과가 발생할 수 있습니다. 싱글 스레드는 이러한 문제를 방지합니다.

자바스크립트 자체는 싱글 스레드로 동작하지만, 비동기 작업은 자바스크립트 엔진 외부의 환경(브라우저 또는 Node.js)에 의해 처리됩니다.

- 자바스크립트 엔진: 코드를 실행하는 싱글 스레드 환경을 제공합니다. 여기에는 콜 스택이 포함됩니다.
- Web API (브라우저 환경): 브라우저에서 제공하는 API로, DOM, AJAX, setTimeout 등의 비동기 작업을 처리합니다.
- 이벤트 루프와 태스크 큐: 브라우저나 Node.js 환경에서 관리합니다.
  - 이벤트 루프는 계속해서 콜 스택과 태스크 큐를 확인합니다.
  - 비동기 작업이 완료되면 그 결과(콜백)를 태스크 큐에 추가합니다.
  - 콜 스택이 비었을 때, 이벤트 루프가 태스크 큐의 작업을 콜 스택으로 이동시킵니다.
- 비동기 처리 과정
  - 자바스크립트 코드에서 비동기 작업(예: setTimeout)을 만나면 Web API로 해당 작업을 넘깁니다.
  - Web API는 별도의 스레드에서 이 작업을 처리합니다.
  - 작업이 완료되면 콜백을 태스크 큐에 추가합니다.
  - 이벤트 루프는 콜 스택이 비었을 때 태스크 큐의 콜백을 콜 스택으로 이동시켜 실행합니다.

이러한 메커니즘 덕분에 자바스크립트는 싱글 스레드로 동작하면서도 비동기 작업을 효율적으로 처리할 수 있습니다. 브라우저나 Node.js 환경이 멀티스레딩을 활용하여 비동기 작업을 처리하고, 자바스크립트 엔진은 이 결과를 받아 처리하는 방식입니다.

<br>

## 재귀함수의 장점과 단점은 어떤 것들이 있을까요?

재귀 함수는 자기 자신을 호출하는 함수입니다.

### 장점

1. 코드의 간결성: 복잡한 문제를 간단하고 명확하게 표현할 수 있습니다.
2. 문제의 자연스러운 표현: 재귀적 성질을 가진 문제(예: 트리 구조, 그래프 탐색, 수학적 정의)를 직관적으로 구현할 수 있어, 문제 정의와 해결책 사이의 갭을 줄일 수 있습니다.

### 단점

1. 스택 오버플로우: 각 재귀 호출마다 새로운 스택 프레임이 생성되어 메모리 사용량이 증가합니다. 이렇게 재귀 호출이 깊어진다면 스택 메모리가 초과되어 스택 오버플로우가 발생할 수 있습니다.
2. 성능 저하: 반복문에 비해 함수 호출이 빈번해지면서 성능이 떨어질 수 있습니다.
3. 디버깅의 어려움: 복잡한 재귀 함수는 디버깅이 어려울 수 있습니다.
4. 무한 재귀의 위험: 종료 조건을 잘못 설정하면 무한 루프에 빠질 수 있습니다.

<br>

## 재귀 방식과 iterative 방식의 장단점은 무엇인가요?

재귀 방식은 위 재귀 함수 장단점과 유사하고, 반복 방식의 장단점은 다음과 같습니다.

### 장점

1. 메모리 효율성: 재귀에 비해 메모리 사용량이 적으며, 스택 오버플로우 위험이 없습니다.
2. 성능 향상: 함수 호출 오버헤드가 없어 빠르게 작동합니다.
3. 직관적인 흐름 제어: 프로그램의 실행 흐름을 명시적으로 볼 수 있어 이해하기 쉬운 경우가 많습니다.

### 단점

1. 복잡성 증가: 문제를 명시적으로 제어해야 하므로, 복잡한 로직의 경우 코드가 복잡해질 수 있습니다.
2. 가독성 저하: 특히 깊은 반복문이나 복잡한 상태 관리가 필요한 경우 가독성이 떨어질 수 있습니다.

결론적으로, 재귀는 문제의 구조가 자연스럽게 재귀적으로 정의될 때 유리하고, 반복은 메모리 효율성과 성능을 중요시할 때 선택합니다.

<br>

## 제어 컴포넌트와 비제어 컴포넌트

제어 컴포넌트는 React의 state에 의해 입력값이 관리되는 방식입니다. 이 방식에서는 value 속성을 통해 입력값을 React state와 동기화하며, 사용자의 입력에 따라 state를 업데이트합니다. 이는 실시간 유효성 검사나 입력값에 따른 UI 업데이트가 필요한 경우에 특히 유용합니다. 예를 들어, 사용자가 입력하는 동안 즉시 피드백을 제공해야 하는 경우 제어 컴포넌트를 사용하면 효과적입니다.

반면, 비제어 컴포넌트는 DOM 자체에서 폼 데이터를 관리합니다. 이 방식에서는 ref를 사용하여 DOM 노드에 직접 접근하여 값을 가져옵니다. 초기값은 defaultValue 속성으로 설정할 수 있습니다. 비제어 컴포넌트는 폼 요소가 많고 실시간 상태 관리가 필요 없는 경우에 적합합니다. 특히 `<input type="file" />`과 같이 프로그래밍적으로 값을 설정할 수 없는 요소는 항상 비제어 컴포넌트로 다루어야 합니다.

`<input type="file" />`이 항상 비제어 컴포넌트인 이유는 보안과 관련이 있습니다. 파일 경로를 프로그래밍적으로 설정할 수 있다면 악성 스크립트가 사용자의 파일 시스템에 접근할 수 있는 보안 위험이 생깁니다. 따라서 브라우저는 이러한 입력 요소의 값을 직접 설정하는 것을 허용하지 않습니다.

그러나 비제어 컴포넌트를 사용하더라도 파일 업로드 시 크기 제한 등의 기능은 구현할 수 있습니다. 이는 ref와 onChange 이벤트를 조합하여 선택된 파일의 정보를 확인하고, 조건에 따라 파일 입력값을 초기화하는 방식으로 구현할 수 있습니다.

<br>
