# Javascript

## var, let, const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.
먼저 var에 대해 말씀드리면, 이는 ES5까지 변수 선언의 유일한 방법이었습니다. var는 함수 스코프를 가지는데, 이는 함수 내에서 선언되면 그 함수 전체에서 접근 가능하다는 뜻입니다. 함수 밖에서 선언되면 전역 스코프를 가지게 되어 window 객체의 속성이 되기도 합니다. var의 특징적인 점은 호이스팅인데, 변수 선언이 스코프의 최상단으로 끌어올려지면서 동시에 undefined로 초기화됩니다. 이 때문에 변수를 선언하기 전에 접근해도 에러가 나지 않고 undefined를 반환하는 특징이 있어요. 또한 var로 선언한 변수는 재선언과 재할당이 자유롭습니다. 이러한 단점을 보완하기 위해 ES6에서 let과 const가 도입되었습니다.

이 둘은 블록 스코프를 가져서 선언된 블록 내에서만 접근할 수 있습니다. 블록 스코프는 중괄호 {} 로 둘러싸인 영역을 말합니다. 호이스팅될 때도 var와 달리 초기화되지 않은 상태로 TDZ라는 곳에 놓이게 됩니다. TDZ는 변수 선언 전에 접근할 수 없는 구간을 말하는데, 이로 인해 변수 사용의 예측 가능성이 높아집니다.
let은 재할당이 필요한 변수를 선언할 때 사용합니다. const는 재할당이 불가능한 상수를 선언할 때 씁니다. 한 번 값이 할당되면 변경할 수 없어 코드의 안정성을 높여줍니다.

이런 특성들 때문에 요즘은 var의 사용을 지양하고 주로 let과 const를 사용합니다. 변수 선언 시 기본적으로 const를 사용하고, 재할당이 필요한 경우에만 let을 사용하는 것이 좋은 관행입니다.

## 자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?
스레드란 프로세스 내에서 운영체제로부터 할당받는 자원을 실행하는 단위입니다. 여기서 프로세스는 운영체제에서 프로그램을 실행하는 독립적인 작업 단위를 말합니다. 프로그램은 특정 작업을 수행하기 위해 작성된 코드 뭉치입니다.
브라우저는 멀티프로세스이면서 멀티 스레드입니다. 각 프로세스 내에서 다양한 작업을 처리할 수 있게 해줍니다. 웹 개발자가 작성한 자바스크립트 코드는 렌더러 프로세스의 메인 스레드에서 실행이 되어 V8 엔진이 동작하기 때문에 싱글 스레드로 작동합니다.

## 자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?
고차함수는 함수를 인자로 받거나 함수를 반환하는 함수를 말합니다. 이는 JavaScript에서 함수가 일급 객체로 취급되기 때문에 가능한 개념입니다. 고차함수의 장점으로는 다음과 같습니다.

첫째, 고차함수는 코드의 유연성을 증가시킵니다. 함수를 인자로 받거나 반환함으로써, 동작을 매개변수화할 수 있어 다양한 상황에 대응할 수 있습니다. 예를 들어, 배열의 filter 메소드는 어떤 조건으로 필터링할지를 함수로 받아 유연하게 대응할 수 있게 해줍니다.

둘째, 고차함수는 로직의 재사용성을 높입니다. 공통된 패턴을 추상화하여 여러 상황에서 재사용할 수 있게 해줍니다. 이는 코드의 중복을 줄이고 유지보수를 용이하게 만듭니다.

셋째, 고차함수는 코드의 가독성을 향상시킵니다. map, reduce와 같은 고차함수들은 데이터 처리의 의도를 명확히 드러내어, 복잡한 로직을 더 이해하기 쉬운 형태로 표현할 수 있게 해줍니다.

마지막으로, 고차함수는 함수형 프로그래밍을 가능하게 하여 side effect를 줄이고 테스트하기 쉬운 코드를 작성하는 데 도움을 줍니다. 이는 결과적으로 더 안정적이고 유지보수가 쉬운 코드를 만들 수 있게 합니다

## 자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.
try...catch는 JavaScript에서 에러를 처리하기 위한 구문입니다. 이 구문의 기본적인 작동 방식은 다음과 같습니다.

1. 먼저 try 블록 안의 코드가 실행됩니다.
2. 에러가 없다면, try 블록 안의 코드가 모두 실행되고 catch 블록은 건너뜁니다.
3. 에러가 발생하면, try 블록의 실행이 즉시 중단되고 제어 흐름이 catch 블록으로 넘어갑니다.

catch 블록은 에러 객체를 매개변수로 받습니다. 이 객체는 발생한 에러에 대한 정보를 담고 있으며, 주로 name과 message 속성을 통해 에러의 종류와 설명을 제공합니다.

try...catch는 주로 다음과 같은 상황에서 사용됩니다.

1. 외부 리소스와의 상호작용: 파일 읽기/쓰기, 네트워크 요청 등에서 발생할 수 있는 에러 처리
2. 사용자 입력 처리: 잘못된 형식의 입력 등으로 인한 에러 관리
3. 복잡한 연산이나 타입 변환 과정에서 발생할 수 있는 예외 상황 처리

추가로, finally 블록을 사용하여 에러 발생 여부와 관계없이 항상 실행되어야 하는 코드를 지정할 수 있습니다.

try...catch는 오직 런타임 에러에만 동작하며, 문법적으로 올바르지 않은 코드에 대해서는 작동하지 않습니다. 또한, try...catch는 비동기적으로 발생하는 에러를 잡을 수 없으므로, 비동기 코드의 에러 처리에는 추가적인 방법이 필요합니다.

## 프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.
프로미스는 자바스크립트에서 비동기 작업을 더 효율적으로 다루기 위해 도입된 객체입니다. 프로미스를 사용하는 주요 이유는 다음과 같습니다.

첫째, 프로미스는 비동기 코드를 동기 코드와 유사한 흐름으로 작성할 수 있게 해줍니다. 이는 코드의 가독성과 유지보수성을 향상시킵니다. 특히 프로미스는 비동기 작업의 결과를 반환값으로 다룰 수 있게 해주어, 동기 코드의 패턴과 유사하게 로직을 구성할 수 있습니다.

둘째, 프로미스는 에러 핸들링을 더 효과적으로 할 수 있게 해줍니다. 프로미스 체인에서 발생하는 모든 에러를 하나의 catch 블록에서 처리할 수 있어, try-catch 구문과 유사한 방식으로 에러를 관리할 수 있습니다. 이는 비동기 코드의 에러 처리를 더 직관적이고 일관성 있게 만듭니다.

셋째, 프로미스는 비동기 작업의 상태를 객체로 표현함으로써, 비동기 작업의 결과를 더 유연하게 다룰 수 있게 해줍니다. 이 객체는 pending, fulfilled, rejected 상태를 가질 수 있으며, 이를 통해 비동기 작업의 진행 상황을 명확하게 파악할 수 있습니다.

넷째, 프로미스는 여러 비동기 작업을 쉽게 조합하고 제어할 수 있게 해줍니다. Promise.all, Promise.race 등의 메서드를 통해 여러 프로미스를 병렬로 처리하거나, 순차적으로 처리하는 등 복잡한 비동기 로직을 간단하게 구현할 수 있습니다.

마지막으로, 프로미스는 콜백 함수를 사용하는 전통적인 방식에 비해 코드의 흐름을 더 명확하게 표현할 수 있게 해줍니다. 이는 소위 '콜백 지옥'을 피하는데 도움을 주지만, 이것이 프로미스의 주된 목적은 아닙니다.

## 자바스크립트의 Strict Mode에 대해 설명해보세요.
JavaScript의 Strict Mode는 코드의 안정성과 품질을 향상시키기 위한 특별한 실행 모드입니다. 이 모드는 ECMAScript 5에서 도입되었으며, 코드를 더 엄격하게 해석하고 실행합니다.

Strict Mode를 활성화하려면 스크립트나 함수의 시작 부분에 'use strict'; 지시문을 추가하면 됩니다. 이 모드는 여러 가지 중요한 특징을 가지고 있습니다.

먼저, Strict Mode는 일반적인 코딩 실수를 잡아내고 예외를 발생시킵니다. 예를 들어, 선언되지 않은 변수를 사용하거나 읽기 전용 속성에 값을 할당하려고 할 때 오류를 발생시킵니다. 이는 개발자가 잠재적인 버그를 조기에 발견하고 수정할 수 있게 해줍니다.

또한, Strict Mode는 이전에는 무시되던 일부 JavaScript 오류를 실제 오류로 변환합니다. 예를 들어, 8진수 구문의 사용이나 with 문의 사용을 금지합니다. 이는 코드의 명확성과 예측 가능성을 높입니다.

보안 측면에서도 Strict Mode는 중요한 역할을 합니다. 예를 들어, this의 전역 객체 바인딩을 방지하여 의도하지 않은 전역 객체 수정을 막습니다. 함수 내에서 this가 undefined로 설정되어, 전역 객체를 참조하는 실수를 방지할 수 있습니다.

Strict Mode는 또한 미래의 ECMAScript 버전을 위한 준비를 돕습니다. 일부 구문을 금지하거나 제한함으로써, 향후 버전에서 정의될 수 있는 구문과의 충돌을 방지합니다.

그러나 Strict Mode의 사용에는 주의가 필요합니다. 기존의 non-strict 코드를 Strict Mode로 전환할 때는 세심한 테스트가 필요합니다. 일부 코드는 Strict Mode에서 다르게 동작할 수 있기 때문입니다.

또한, Strict Mode는 브라우저의 호환성 문제를 완전히 해결하지는 못합니다. 일부 오래된 브라우저에서는 Strict Mode를 지원하지 않을 수 있으므로, 대상 환경을 고려해야 합니다.

## 렉시컬 환경과 렉시컬 스코프란 무엇인가요?
렉시컬 환경과 렉시컬 스코프는 JavaScript에서 변수와 함수의 접근성을 결정하는 중요한 개념입니다.

렉시컬 스코프란, JavaScript에서 변수와 함수의 접근 범위가 코드가 작성된 물리적 위치에 의해 결정되는 방식을 말합니다. 즉, 함수가 어디서 호출되었는지가 아니라 어디서 정의되었는지에 따라 그 함수의 스코프가 결정됩니다.

예를 들어, 함수 내부에 정의된 변수는 그 함수의 외부에서 접근할 수 없지만, 함수는 자신이 정의된 곳의 외부 변수에 접근할 수 있습니다. 이는 코드를 읽을 때 변수의 범위를 쉽게 파악할 수 있게 해줍니다.

렉시컬 환경은 이러한 렉시컬 스코프를 구현하기 위한 JavaScript 엔진의 내부 메커니즘입니다. 이는 특정 코드 블록이나 함수가 실행될 때 생성되는 변수와 함수 정보를 담고 있는 자료 구조입니다.

렉시컬 환경은 두 가지 주요 컴포넌트로 구성됩니다.

1. 환경 레코드: 현재 스코프의 모든 지역 변수, 함수 선언 등을 저장합니다.
2. 외부 렉시컬 환경에 대한 참조: 상위 스코프의 렉시컬 환경을 가리킵니다.

이러한 구조 덕분에 JavaScript 엔진은 변수를 찾을 때 현재 환경에서 시작하여 점차 상위 환경으로 올라가며 검색할 수 있습니다.

## 0.1 + 0.2 === 0.3는 왜 false인가요?
JavaScript뿐만 아니라 대부분의 프로그래밍 언어에서 발생하는 부동소수점 연산의 특성 때문입니다.
컴퓨터는 내부적으로 이진법을 사용하여 숫자를 표현합니다. 그런데 10진법의 소수를 정확히 이진법으로 표현하는 것이 불가능한 경우가 있습니다. 0.1과 0.2도 이에 해당합니다.
0.1을 이진법으로 표현하면 무한히 반복되는 숫자가 됩니다: 0.0001100110011001... (2진법)
0.2도 마찬가지입니다: 0.001100110011001... (2진법)
컴퓨터는 이를 64비트 부동소수점 형식(IEEE 754)으로 근사하여 저장합니다. 이 과정에서 아주 작은 오차가 발생하고, 이 오차들이 덧셈 연산을 거치면서 눈에 띄는 차이를 만들어냅니다.
실제로 JavaScript에서 0.1 + 0.2를 계산하면 0.30000000000000004라는 결과가 나옵니다. 이는 0.3과 정확히 일치하지 않으므로, === 연산자로 비교했을 때 false가 반환되는 것입니다.

이러한 문제를 해결하기 위해서 반올림을 위한 toFixed() 이나 정수로 변환하는 방법을 사용할 수 있습니다.

# React

## 리액트의 상태 끌어올리기는 어떤 단점이 있을까요?
리액트의 상태 끌어올리기는 여러 컴포넌트 간에 상태를 공유해야 할 때 유용한 패턴이지만, 몇 가지 단점이 있습니다.

첫째, 컴포넌트 간의 결합도가 높아질 수 있습니다. 상태를 공통 부모 컴포넌트로 끌어올리면, 해당 상태에 의존하는 모든 자식 컴포넌트들이 부모 컴포넌트에 더 강하게 연결됩니다. 이는 컴포넌트의 재사용성을 저하시킬 수 있습니다.

둘째, 과도한 리렌더링이 발생할 수 있습니다. 상태가 변경될 때마다 그 상태를 공유하는 모든 자식 컴포넌트들이 리렌더링됩니다. 이는 성능 저하로 이어질 수 있으며, 특히 대규모 애플리케이션에서 문제가 될 수 있습니다.

셋째, 코드의 복잡성이 증가할 수 있습니다. 여러 레벨의 컴포넌트를 거쳐 props를 전달해야 하는 경우, 이른바 'prop drilling' 문제가 발생할 수 있습니다. 이는 코드를 이해하고 유지보수하기 어렵게 만듭니다.

넷째, 상태 관리의 책임이 한 컴포넌트에 집중되어, 해당 컴포넌트가 비대해질 수 있습니다. 이는 단일 책임 원칙을 위배하고, 컴포넌트의 복잡성을 증가시킵니다.

마지막으로, 데이터 흐름을 추적하기 어려워질 수 있습니다. 특히 여러 레벨의 컴포넌트를 거쳐 상태와 콜백 함수가 전달되는 경우, 데이터의 흐름을 파악하기 어려워져 디버깅이 복잡해질 수 있습니다.

이러한 단점들로 인해, 복잡한 상태 관리가 필요한 대규모 애플리케이션에서는 Redux, MobX, Recoil 등의 상태 관리 라이브러리를 사용하거나, Context API를 활용하는 것이 더 효과적일 수 있습니다.

## 가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?
가상돔(Virtual DOM)은 실제 DOM의 가벼운 복사본으로, 메모리상에 존재하는 JavaScript 객체입니다. 이 개념은 웹 애플리케이션의 성능 최적화를 위해 도입되었습니다. 가상돔의 탄생 배경을 살펴보면, 복잡한 웹 애플리케이션에서 발생하는 잦은 DOM 조작으로 인한 성능 저하 문제를 해결하기 위한 노력에서 비롯되었습니다.

가상돔의 주요 장점은 성능 최적화와 개발 편의성입니다. 실제 DOM 조작을 최소화함으로써 렌더링 성능을 향상시키고, 개발자가 상태 기반의 UI를 쉽게 구현할 수 있게 해줍니다. 또한, 브라우저 DOM에 직접적으로 의존하지 않기 때문에 다양한 환경에서 활용할 수 있는 크로스 플랫폼 지원이 가능합니다.

하지만 가상돔에도 단점이 있습니다. 추가적인 JavaScript 객체를 유지해야 하므로 메모리 사용량이 증가합니다. 또한, 작은 변경사항에도 전체 가상돔 트리를 비교해야 하는 오버헤드가 발생할 수 있습니다. 이는 특히 대규모 애플리케이션에서 성능 저하로 이어질 수 있습니다.

이러한 오버헤드에 대비하기 위해 React는 여러 최적화 기법을 제공합니다. useCallback은 함수의 불필요한 재생성을 방지하여 자식 컴포넌트의 리렌더링을 줄입니다. useMemo는 계산 비용이 큰 값의 재계산을 방지합니다. React.memo는 프로퍼티 변경이 없을 때 컴포넌트의 리렌더링을 막아줍니다. 이러한 도구들을 적절히 사용하면 가상돔의 오버헤드를 상당 부분 줄일 수 있습니다.

## 리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.
리액트의 Diffing Algorithm은 가상 DOM 트리를 효율적으로 업데이트하는 핵심 메커니즘입니다. 이 알고리즘은 O(n) 복잡도로 동작하며, 두 가지 주요 가정에 기반합니다. 서로 다른 타입의 엘리먼트는 다른 트리를 생성한다는 것과 개발자가 key prop을 통해 여러 렌더링에서 안정적인 자식 엘리먼트를 표시할 수 있다는 것입니다.

알고리즘은 두 트리의 루트 엘리먼트부터 비교를 시작합니다. 엘리먼트 타입이 다르면 이전 트리를 버리고 새로운 트리를 처음부터 구축합니다. 같은 타입의 DOM 엘리먼트인 경우, 속성을 비교하여 변경된 속성만 업데이트합니다.

컴포넌트 엘리먼트가 같은 타입이면, 리액트는 인스턴스를 유지하면서 새 엘리먼트의 props에 맞게 기존 컴포넌트 인스턴스의 props를 업데이트합니다. 이 과정에서 리액트는 컴포넌트의 render 메서드를 호출하여 새로운 엘리먼트 트리를 얻습니다. 그 다음, 이전에 렌더링된 엘리먼트 트리와 새로 반환된 엘리먼트 트리를 재귀적으로 비교합니다.

함수형 컴포넌트의 경우, 리액트는 해당 함수를 새로운 props로 다시 호출합니다. 클래스 컴포넌트의 경우, render 메서드가 호출되고 그 결과가 비교됩니다. 업데이트가 완료된 후, 함수형 컴포넌트에서는 useEffect 훅이, 클래스 컴포넌트에서는 componentDidUpdate 라이프사이클 메서드가 호출됩니다.

자식 엘리먼트들은 재귀적으로 처리되며, key prop을 사용하여 효율적인 비교를 수행합니다. key를 통해 리액트는 기존 트리와 새 트리의 자식들을 매칭하여 불필요한 재생성을 방지합니다.

이 알고리즘의 휴리스틱 특성으로 인해 특정 상황에서는 성능 저하가 발생할 수 있습니다. 예를 들어, 서브트리가 다른 위치로 이동한 경우 전체 서브트리를 리렌더링하게 됩니다.

## 리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?
리액트에서 상태 업데이트가 비동기적으로 실행된다는 것은 상태를 변경하는 함수(예: setState 또는 useState의 상태 설정 함수)를 호출한 직후에 상태가 즉시 업데이트되지 않는다는 의미입니다. 이는 리액트의 성능 최적화 전략 중 하나로, 여러 가지 중요한 이유가 있습니다.

첫째, 리액트는 여러 상태 업데이트를 일괄 처리(batching)하여 불필요한 리렌더링을 줄입니다. 만약 여러 상태 업데이트가 동시에 발생한다면, 리액트는 이들을 모아서 한 번의 리렌더링으로 처리합니다. 이는 애플리케이션의 전반적인 성능을 크게 향상시킵니다.

둘째, 비동기적 업데이트를 통해 리액트는 중요한 업데이트를 우선적으로 처리할 수 있습니다. 예를 들어, 사용자 입력에 대한 응답을 지연시키지 않으면서 백그라운드 작업을 수행할 수 있습니다.

셋째, 이 방식은 리액트가 내부적으로 상태 업데이트를 최적화할 수 있는 유연성을 제공합니다. 리액트는 필요에 따라 업데이트를 지연시키거나 우선순위를 조정할 수 있어, 더 효율적인 렌더링 프로세스를 구현할 수 있습니다.

그러나 이러한 비동기적 특성으로 인해 상태 업데이트의 정확한 타이밍을 예측하기 어려울 수 있습니다. 따라서 상태 업데이트 직후의 새로운 상태값에 의존하는 로직이 있다면, 상태 업데이트 함수의 콜백이나 useEffect 훅을 사용하여 처리해야 합니다.

최신 버전의 리액트에서는 이러한 비동기적 업데이트 처리가 더욱 개선되어, 자동 배칭(Automatic Batching)이 이벤트 핸들러 외부에서의 업데이트에도 적용됩니다. 이는 더 일관된 동작과 향상된 성능을 제공합니다.

## 리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?
리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것은 일반적으로 권장되지 않습니다. useCallback은 특정 상황에서 성능 최적화에 도움이 될 수 있지만, 무분별한 사용은 오히려 성능 저하를 일으킬 수 있습니다.

useCallback은 메모이제이션된 콜백을 반환하는 훅으로, 의존성 배열이 변경될 때만 새로운 함수를 생성합니다. 이는 불필요한 리렌더링을 방지하는 데 도움이 될 수 있지만, 동시에 메모리 사용량을 증가시키고 코드 복잡성을 높일 수 있습니다.

useCallback의 주요 사용 사례는 다음과 같습니다.

1. 자식 컴포넌트에 콜백을 prop으로 전달할 때, 특히 그 자식 컴포넌트가 React.memo로 최적화되어 있는 경우
2. useEffect의 의존성 배열에 함수를 포함시켜야 할 때

그러나 모든 함수를 useCallback으로 감싸는 것은 다음과 같은 문제를 야기할 수 있습니다.

1. 불필요한 메모리 사용: 각 useCallback 호출은 메모리를 사용하여 이전 함수 참조를 저장합니다.
2. 코드 복잡성 증가: 과도한 useCallback 사용은 코드를 읽고 유지보수하기 어렵게 만듭니다.
3. 성능 저하: useCallback 자체도 비용이 들기 때문에, 불필요한 경우 오히려 성능을 저하시킬 수 있습니다.

리액트 개발 팀의 Dan Abramov는 이에 대해 다음과 같이 언급했습니다. "대부분의 경우 useCallback은 필요하지 않습니다. 함수를 props로 전달하는 것만으로는 성능 문제를 일으키지 않습니다. useCallback은 자식 컴포넌트가 불필요하게 리렌더링되는 것을 방지하기 위한 최적화 도구입니다."

따라서 useCallback은 실제 성능 병목 현상이 발생하는 경우에만 선택적으로 사용하는 것이 좋습니다. 대부분의 경우, 리액트의 기본 동작만으로도 충분히 효율적입니다. 성능 최적화가 필요한 경우에는 프로파일링을 통해 실제 성능 향상이 있는지 확인한 후 useCallback을 적용하는 것이 바람직합니다.

결론적으로, 모든 함수를 useCallback으로 감싸는 것보다는 필요한 경우에만 선택적으로 사용하는 것이 리액트 애플리케이션의 성능과 유지보수성을 향상시키는 데 더 효과적입니다.