# JavaScript

## var, let, const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.

> `var`는 함수 스코프, 전역 스코프를 가지고 있고 호이스팅 되어 선언전에 사용이 가능하고 재선언과 재할당이 가능합니다.<br/> > `let`과 `const`는 블록 스코프를 가지며, TDZ로 인해 선언 전에 사용이 불가능합니다.<br/> > `let`은 재할당만 가능하고, `const`는 재선언, 재할당이 불가능합니다.<br/>
> 일반적으로 `const`를 기본으로 사용하고, 재할당이 필요한 경우에만 `let`을 사용하며, `var`는 가급적 피하는 것이 좋습니다.<br/>

<br/>

## 자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?

> 스레드는 프로그램 실행의 최소 단위입니다.<br/>
> 싱글 스레드인 자바스크립트는 한 번에 하나의 작업만 처리할 수 있습니다.<br/>
> 브라우저는 멀티 스레드를 지원하지만 여러 스레드로 DOM 조작시 일관성 문제가 발생하기 때문에<br/>
> 싱글스레드인 자바스크립트의 비동기 처리를 통해 동시성을 구현해 효율적으로 작업할 수 있습니다.<br/>

<br/>

## 자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?

> 고차함수의 장점은 코드의 추상화와 재사용성 향상에 있습니다.<br/>
> 함수를 인자로 전달하거나 반환할 수 있어 복잡한 로직을 간결하게 표현해 가독성을 높일 수 있습니다.<br/>
> 또한 순수 함수 개념을 적용해 예측 가능한 코드를 작성할 수 있어 비동기 처리 작업을 효율적으로 구현할 수 있습니다.<br/>

<br/>

## 자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하나요?

> `try...catch`는 에러 처리를 위한 구문입니다.<br/> > `try` 블록에서 실행한 코드에서 에러가 발생한경우 `catch` 블록에서 처리하게 됩니다.<br/>
> 주로 API 호출 등 실패 가능성이 있는 작업에 적용해 에러 발생 시에도 프로그램을 중단시키지 않고 대응할 수 있습니다.<br/>

<br/>

## 프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.

> 프로미스를 사용하면 코드를 더 읽기 쉽게 구조화할 수 있고 비동기 작업을 효과적으로 처리할 수 있습니다.<br/>
> 여기서 말하는 효과적인 처리란,<br/> > `.then` 을 사용한 비동기작업의 순차 실행,<br/> > `Promise.all()` 을 사용한 비동기 작업의 병렬 실행,<br/> > `pending`, `fulfilled`, `rejected` 의 세가지 상태를 통한 비동기 작업 관리 등이 있습니다.<br/>

<br/>

## 자바스크립트의 Strict Mode에 대해 설명해보세요.

> `Strict Mode` 는 코드의 최상단에 `use strict` 를 선언해 사용할 수 있습니다.<br/> > `Strict Mode` 는 개발자의 실수를 에러로 변환하여 디버깅을 용이하게 합니다.<br/>
> 그리고 변수 선언을 강제하여 메모리 사용을 최적화하고, 변수 스코프를 쉽게 파악하게 해 변수 검색 속도에 향상 시킬 수 있습니다.<br/>

<br/>

## 렉시컬 환경과 렉시컬 스코프란 무엇인가요?

> 렉시컬 환경은 변수와 함수 선언을 저장하고 외부 환경을 참조해 스코프를 구현하는 자료구조입니다.<br/>
> 렉시컬 스코프는 코드의 작성 위치에 따라 변수와 함수의 접근 범위가 결정되는 것을 말합니다.<br/>
> 이 두 개념을 통해 클로저, 변수 호이스팅, 스코프 체인 등을 구현할 수 있습니다.<br/>

<br/>

## 0.1 + 0.2 === 0.3는 왜 false인가요?

> 컴퓨터는 숫자를 이진법으로 저장합니다.<br/> > `0.1`, `0.2`와 같은 십진 소수는 이진법으로 정확하게 표현할수 없어서 근사값으로 저장되기 때문에 연산결과가 정확히 `0.3` 이 되지 않습니다.<br/>
> 이를 해결하기 위해서는 정수로 변환해 계산하거나, 소수점 자리수를 제한해 계산하는 방법을 사용할 수 있습니다.<br/>

<br/><br/>

# React

## 리액트의 상태 끌어올리기는 어떤 단점이 있을까요?

> 상태 끌어올리기의 주요 목적은 여러 컴포넌트 간에 상태를 공유하는 것이지만<br/>
> 공통 부모 컴포넌트와 해당 컴포넌트의 거리가 멀어지면 상위 컴포넌트가 복잡성해지고,<br/>
> 상태와 이벤트 핸들러를 여러 자식 컴포넌트로 전달하는 `props drilling` 문제를 야기할 수 있습니다.<br/>
> 그리고 상위 컴포넌트의 상태가 변경되면 모든 하위 컴포넌트가 리렌더링 되는 등 불필요한 렌더링을 유발할 수 있습니다.<br/>

<br/>

## 가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?

> 가상 DOM 은 실제 DOM 의 복사본입니다.<br/>
> 이전 가상 DOM 과 변경된 가상 DOM 을 비교해 변경된 부분만 실제 DOM에 적용하기 때문에 불필요한 렌더링을 줄여 성능을 향상시킵니다.<br/>
> 하지만 가상 DOM 을 유지해야 하기때문에 메모리 사용량이 증가하고, 때로는 직접 DOM 을 조작하는 것이 효율적일 수 있지만 가상 DOM 을 사용해 복잡해질 수 있습니다.<br/>

<br/>

## 리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.

> **Diffing Algorithm**은 가상 DOM(Virtual DOM)을 업데이트하는 알고리즘으로 먼저 이전 가상 DOM 트리와 새로운 가상 DOM 트리를 재귀적으로 비교합니다.<br/>
> 엘리먼트의 타입이 다르면 삭제 후에 새로운 DOM 노드를 삽입하고 같다면 변경된 속성만 업데이트합니다.<br/>
> 리스트 아이템은 키를 통해 비교해 불필요한 렌더링을 줄이고 불변성을 활용해 참조 여부만 비교해 변경여부를 빠르게 확인할 수 있습니다.<br/>

<br/>

## 리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?

> 리액트의 상태 업데이트가 비동기로 실행된다는 말은 상태 업데이트 함수를 호출한 직후에 상태가 즉시 업데이트 되지 않는다는 말입니다.<br/>
> 그 이유는 React의 성능 최적화 때문인데, 불필요한 렌더링을 줄이고 컴포넌트의 일관성을 유지하기 위해 여러 상태 업데이트를 하나의 렌더링으로 배치 처리하기 때문입니다.<br/>

<br/>

## 리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?

> 모든 함수를 `useCallback`으로 감싸면 오히려 성능이 저하되고 가독성이 떨어질 수 있습니다.<br/> > `useCallback` 자체도 메모리와 계산 비용이 들고 의존성 배열 관리를 잘못 할 경우 예상치 못한 버그가 발생할 수 있습니다.<br/> > `useCallback` 은 자식 컴포넌트의 prop으로 전달되는 함수, useEffect의 의존성 배열에 포함되는 함수, 복잡한 계산이 있는 함수에 적용하는 것이 좋습니다.<br/>
