# 목차

- JavaScript
  - [가비지 컬렉터란 무엇이며, 작동 원리에 대해 아는대로 최대한 자세히 설명해보세요.](#가비지-컬렉터란-무엇이며-작동-원리에-대해-아는대로-최대한-자세히-설명해보세요)
  - [메모리 누수란 무엇이며, 자바스크립트에서는 어떤 경우에 발생할 수 있을까요?](#메모리-누수란-무엇이며-자바스크립트에서는-어떤-경우에-발생할-수-있을까요)
  - [자바스크립트는 누가 언제 어디서 왜 만들었나요?](#자바스크립트는-누가-언제-어디서-왜-만들었나요)
  - [자바스크립트는 왜 싱글 스레드일까요?](#자바스크립트는-왜-싱글-스레드일까요)
  - [재귀함수의 장점과 단점은 어떤 것들이 있을까요?](#재귀함수의-장점과-단점은-어떤-것들이-있을까요)
  - [재귀 방식과 iterative 방식의 장단점은 무엇인가요?](#재귀-방식과-iterative-방식의-장단점은-무엇인가요)
  - [제어 컴포넌트와 비제어 컴포넌트](#제어-컴포넌트와-비제어-컴포넌트)
- React
  - [리덕스의 이름은 왜 리덕스일까요?](#리덕스의-이름은-왜-리덕스일까요)
  - [여러 개의 액션을 연속적으로 발생시키지 말아야 하는 이유는 무엇일까요? 명확한 이유와 예시를 이용해 설명해주세요.](#여러-개의-액션을-연속적으로-발생시키지-말아야-하는-이유는-무엇일까요-명확한-이유와-예시를-이용해-설명해주세요)
  - [Serialize 할 수 없는 값은 리덕스 상태에 왜 넣지 말라고 하는 것인가요? 명확한 이유와 함께 본인 만의 예시를 이용해 설명해주세요.](#serialize-할-수-없는-값은-리덕스-상태에-왜-넣지-말라고-하는-것인가요-명확한-이유와-함께-본인-만의-예시를-이용해-설명해주세요)
  - [상태 정규화란 무엇이고 왜 하는 것인가요? 명확한 이유와 함께 본인 만의 예시를 이용해 설명해주세요.](#상태-정규화란-무엇이고-왜-하는-것인가요-명확한-이유와-함께-본인-만의-예시를-이용해-설명해주세요)
  - [리덕스의 스토어는 내부적으로 어떻게 상태 변경을 감지할까요? 이와 비슷한 패턴을 가진 다른 예시는 무엇이 있을까요? 여러분은 이런 패턴을 어떤 경우에 적용해볼 수 있을까요?](#리덕스의-스토어는-내부적으로-어떻게-상태-변경을-감지할까요-이와-비슷한-패턴을-가진-다른-예시는-무엇이-있을까요-여러분은-이런-패턴을-어떤-경우에-적용해볼-수-있을까요)
<br>

# Javascript

## 가비지 컬렉터란 무엇이며, 작동 원리에 대해 아는대로 최대한 자세히 설명해보세요.

가비지 컬렉터는 프로그램의 메모리 관리를 자동화하는 시스템입니다. 프로그램이 실행되는 동안 더 이상 사용되지 않는 메모리를 자동으로 식별하고 해제하는 역할을 합니다.

작동 원리를 살펴보면, 먼저 프로그램 실행 중에 새로운 객체가 생성될 때마다 힙 메모리에 공간이 할당됩니다. 그 후 가비지 컬렉터는 주기적으로 또는 특정 조건에서 실행되어 사용되지 않는 객체를 찾아냅니다. 
이를 위해 참조 카운팅, 마크-스윕, 복사 등 다양한 알고리즘을 사용할 수 있죠.
가비지 식별 후에는 해당 객체가 차지하고 있던 메모리 공간을 해제하고, 이를 다시 사용 가능한 상태로 만듭니다. 
일부 시스템에서는 메모리 단편화를 줄이기 위해 살아있는 객체들을 연속된 메모리 공간으로 이동시키는 압축 과정도 수행합니다.
가비지 컬렉터의 유형은 다양한데, Stop-the-World GC, 증분식 GC, 병행 GC 등이 있습니다. 또한 많은 현대적 시스템에서는 세대별 GC를 사용하는데, 이는 객체를 수명에 따라 여러 세대로 분류하여 효율성을 높이는 방식입니다.

가비지 컬렉터의 주요 장점은 메모리 관리를 자동화하여 개발자의 부담을 줄이고, 메모리 누수와 관련 버그를 감소시키는 것입니다. 하지만 성능 오버헤드가 발생할 수 있고, GC 작동 시점과 소요 시간을 예측하기 어려운 단점도 있습니다.

결론적으로, 가비지 컬렉터는 현대 프로그래밍 언어와 런타임 시스템의 핵심 구성 요소로, 메모리 관리를 크게 간소화하고 프로그램의 안정성을 높이는 데 중요한 역할을 합니다. 다만 특정 상황에서는 여전히 수동 메모리 관리가 필요할 수 있으며, GC의 동작 특성을 이해하고 최적화하는 것이 효율적인 프로그램 개발에 중요합니다.

<br>

## 메모리 누수란 무엇이며, 자바스크립트에서는 어떤 경우에 발생할 수 있을까요?

메모리 누수(Memory Leak)는 프로그램이 더 이상 필요하지 않은 메모리를 계속 점유하고 있는 현상을 말합니다. 자바스크립트에서는 가비지 컬렉터가 자동으로 메모리를 관리하지만, 특정 상황에서는 메모리 누수가 발생할 수 있습니다.

메모리 누수는 프로그램이 더 이상 필요하지 않은 메모리를 해제하지 않고 계속해서 참조하여, 사용되지 않는 메모리가 회수되지 못하고 쌓이는 현상을 말합니다.

이로 인해 메모리 사용량이 증가하여 성능 저하나 시스템 오류를 일으킬 수 있습니다.

### 자바스크립트에서 메모리 누수가 발생할 수 있는 일반적인 경우

1. **전역 변수의 오용**
    - `var`, `let`, `const` 키워드 없이 변수를 선언하면 암묵적으로 전역 변수가 되어 메모리에서 해제되지 않습니다.
2. 클로저로 인한 참조 유지
    - 클로저는 함수가 외부 스코프의 변수에 접근할 수 있게 하지만, 이로 인해 불필요한 메모리 참조가 유지될 수 있습니다.
3. 이벤트 리스너 미제거
    - DOM 요소에 이벤트 리스너를 추가한 후, 요소를 제거하면서 리스너를 제거하지 않으면 메모리 누수가 발생합니다.
4. 타이머와 콜백 미정리
    - `setTimeout` 이나 `setInterval` 을 사용한 후, 이를 적절히 해제하지 않으면 메모리가 해제되지 않습니다.
5. DOM 참조 유지
    - 삭제된 DOM 자바스크립트 변수나 데이터 구조에서 계속 참조하면 메모리가 해제되지 않습니다.
6. 순환 참조
    - 객체들이 서로 참조하여 순환 구조를 이루면 가비지 컬렉터가 이를 해제하지 못할 수 있습니다.
  
### 추가. 메모리 누수를 방지하기 위한 방법

1. **변수 선언 시 키워드 사용**: 항상 `var`, `let`, `const`를 사용하여 변수를 선언합니다.
2. **클로저 관리**: 필요 없는 외부 변수 참조를 피하고, 클로저를 사용할 때는 메모리 사용에 유의합니다.
3. **이벤트 리스너 제거**: 요소를 제거하기 전에 `removeEventListener`를 사용하여 이벤트 리스너를 제거합니다.
4. **타이머 해제**: `clearInterval`이나 `clearTimeout`을 사용하여 타이머를 해제합니다.
5. **데이터 구조 정리**: 더 이상 필요 없는 객체나 배열의 참조를 제거하여 가비지 컬렉터가 메모리를 해제할 수 있게 합니다.
6. **순환 참조 피하기**: 객체 간의 순환 참조를 최소화하고, 필요 시 `WeakMap`이나 `WeakSet`을 사용합니다.
7. 
<br>

## 자바스크립트는 누가 언제 어디서 왜 만들었나요?

자바스크립트는 브렌단 아이크(Brendan Eich)가 1995년에 넷스케이프 커뮤니케이션즈(Netscape Communications)에서 만들었습니다.
당시 넷스케이프는 웹 브라우저 시장을 주도하고 있었는데, 웹 페이지에 동적인 기능을 추가할 수 있는 가벼운 스크립팅 언어가 필요했습니다.
이는 서버와의 통신 없이 클라이언트 측에서 간단한 처리를 할 수 있게 하기 위함이었죠.
자바스크립트는 웹 페이지에 인터랙티브한 요소를 추가하고, 사용자 경험을 향상시키는 것을 주요 목적으로 만들어졌습니다.
이후 자바스크립트는 웹 개발의 필수적인 부분이 되었고, 현재는 브라우저뿐만 아니라 서버 사이드 개발, 모바일 앱 개발 등 다양한 분야에서 사용되고 있습니다.

<br>

## 자바스크립트는 왜 싱글 스레드일까요?

자바스크립트는 원래 웹 페이지에서 **가볍고 보조적인 기능**을 수행하기 위해 설계된 언어입니다.

이러한 목적에 따라 **싱글 스레드** 방식을 채택했으며, 이는 웹 브라우저 환경에서 **동시성 문제**(데드락, 데이터 경쟁)를 피하고, **단순하고 효율적인** 동작을 가능하게 합니다.

자바스크립트는 웹 페이지의 사용자 상호작용을 주로 처리하기 때문에, **복잡한 멀티 스레드 관리**가 필요하지 않았습니다.

반면, **멀티 스레드**인 자바는 **복잡한 동시성 문제**를 일으킬 수 있고, 상대적으로 **무겁고 다루기 어렵다는 인식**이 있었습니다. 이에 따라 자바스크립트는 **복잡한 시나리오를 고려할 필요가 없는 싱글 스레드 구조**를 택했습니다.

하지만 자바스크립트는 **이벤트 루프**를 통해 **비동기 작업**을 처리함으로써, 마치 여러 작업을 동시에 처리하는 것처럼 동작할 수 있습니다.

이 방식 덕분에, 자바스크립트는 **싱글 스레드 환경에서도 효율적으로** 비동기 작업을 수행할 수 있습니다.

<br>

## 재귀함수의 장점과 단점은 어떤 것들이 있을까요?

### 장점

1. **문제 해결의 간결함**
    - 재귀함수는 복잡한 문제를 더 간결하고 직관적으로 해결할 수 있습니다.
    - 특히, 문제를 더 작은 하위 문제로 나누어 해결할 때 유용합니다.
2. **코드 가독성**
    - 반복적인 문제를 해결할 때, 재귀를 사용하면 코드가 더 깔끔하고 읽기 쉬워질 수 있습니다.
    - 재귀를 통해 문제의 구조를 자연스럽게 표현할 수 있습니다.
3. **구조적 접근**
    - 재귀는 트리와 그래프 같은 자료구조를 다루는 데 특히 유용합니다.
    - 이러한 자료구조를 자연스럽게 탐색하거나 처리할 수 있습니다.

### 단점

1. **성능 문제**
    - 재귀 호출이 깊어질수록 호출 스택이 커지며, 메모리 사용량이 증가할 수 있습니다.
    - 이는 성능 저하나 스택 오버플로우를 일으킬 수 있습니다.
2. **디버깅 어려움**
    - 재귀함수의 경우, 호출 스택이 복잡하게 얽힐 수 있어 디버깅이 어려울 수 있습니다.
    - 오류 발생 시 문제의 원인을 찾기 힘들 수 있습니다.
3. **성능 저하**
    - 재귀는 반복문에 비해 성능이 떨어질 수 있습니다.
    - 특히, 재귀 호출을 반복문으로 변환하면 성능이 더 개선될 수 있습니다.

<br>

## 재귀 방식과 iterative 방식의 장단점은 무엇인가요?

### **장점**

1. **성능**
    - 반복문(iteration)은 재귀에 비해 성능이 좋을 수 있으며, 메모리 사용량이 적습니다.
    - 스택 프레임을 사용하지 않기 때문에 스택 오버플로우의 위험이 없습니다.
2. **디버깅 용이성**
    - 반복문을 사용하면 스택이 단순하여 디버깅이 더 쉬울 수 있습니다.
    - 상태가 명확하게 관리되므로 오류 추적이 용이합니다.
3. **메모리 효율성**
    - 반복문은 호출 스택을 사용하지 않기 때문에 메모리 사용이 더 효율적입니다.

### **단점**

1. **코드 복잡성**
    - 반복문을 사용하면 코드가 길어지거나 복잡해질 수 있습니다.
    - 재귀에 비해 구조적 접근이 덜 직관적일 수 있습니다.
2. **읽기 어려움**
    - 복잡한 알고리즘을 반복문으로 구현하면 코드가 덜 직관적이거나 이해하기 어려울 수 있습니다.
3. **구조적 접근의 부족**
    - 반복문은 문제를 자연스럽게 구조적으로 표현하기 어려울 수 있으며, 재귀가 필요한 경우에 비해 덜 직관적일 수 있습니다.

<br>

## 제어 컴포넌트와 비제어 컴포넌트

제어 컴포넌트는 React의 state에 의해 입력값이 관리되는 방식입니다. 이 방식에서는 value 속성을 통해 입력값을 React state와 동기화하며, 사용자의 입력에 따라 state를 업데이트합니다. 이는 실시간 유효성 검사나 입력값에 따른 UI 업데이트가 필요한 경우에 특히 유용합니다. 예를 들어, 사용자가 입력하는 동안 즉시 피드백을 제공해야 하는 경우 제어 컴포넌트를 사용하면 효과적입니다.

반면, 비제어 컴포넌트는 DOM 자체에서 폼 데이터를 관리합니다. 이 방식에서는 ref를 사용하여 DOM 노드에 직접 접근하여 값을 가져옵니다. 초기값은 defaultValue 속성으로 설정할 수 있습니다. 비제어 컴포넌트는 폼 요소가 많고 실시간 상태 관리가 필요 없는 경우에 적합합니다. 특히 `<input type="file" />`과 같이 프로그래밍적으로 값을 설정할 수 없는 요소는 항상 비제어 컴포넌트로 다루어야 합니다.

`<input type="file" />`이 항상 비제어 컴포넌트인 이유는 보안과 관련이 있습니다. 파일 경로를 프로그래밍적으로 설정할 수 있다면 악성 스크립트가 사용자의 파일 시스템에 접근할 수 있는 보안 위험이 생깁니다. 따라서 브라우저는 이러한 입력 요소의 값을 직접 설정하는 것을 허용하지 않습니다.

그러나 비제어 컴포넌트를 사용하더라도 파일 업로드 시 크기 제한 등의 기능은 구현할 수 있습니다. 이는 ref와 onChange 이벤트를 조합하여 선택된 파일의 정보를 확인하고, 조건에 따라 파일 입력값을 초기화하는 방식으로 구현할 수 있습니다.

<br>

# React

## 리덕스의 이름은 왜 리덕스일까요?

### 리덕스가 리덕스로 이름이 지어졌는지 명확하게 밝힌 바가 없습니다.

대신 리덕스가 리덕스라는 이름으로 불리게 된 유래로는 몇가지의 가설이 존재합니다.

1. 라틴어 redux의 뜻 "되돌리다", "부활시키다" 에서 가져왔다는 가설
2. 디자인 패턴인 리덕션(Reduction)에서 가져왔다는 가설
3. 함수형 프로그래밍의 reduce와, 페이스북의 Flux 아키텍처를 합친 뜻이라는 가설

### 가장 유력한 가설 =  reduce와 Flux 아키텍처를 합친 뜻

리덕스의 이름은 이러한 두 가지 개념을 반영하려는 의도가 있었을 수 있습니다. 

1. `reduce`는 상태를 업데이트하는 방식을 설명하며
2. Flux는 상태 관리의 단방향 흐름을 제공합니다. 

리덕스는 이 두 가지 아이디어를 통합하여 상태 관리를 보다 효율적이고 예측 가능하게 만들고자 했다는 가설이 가장 유력하다고 합니다!
<br>

## 여러 개의 액션을 연속적으로 발생시키지 말아야 하는 이유는 무엇일까요? 명확한 이유와 예시를 이용해 설명해주세요.

### 1. 연속적인 액션 발생을 피해야 하는 이유

리덕스에서 여러 개의 액션을 연속적으로 발생시키지 말아야 하는 주된 이유는 상태 관리의 예측 가능성을 유지하기 위해서입니다.

1.1 상태의 일관성 유지

- 리덕스는 액션을 디스패치하고 리듀서가 이를 처리하여 새로운 상태를 생성합니다.
- 여러 액션이 연속적으로 발생하면 상태 변경 순서가 비동기적으로 처리되거나 충돌할 수 있습니다.

1.2 상태 불일치 문제

- 특히 비동기 작업이 포함된 경우, 상태 업데이트 타이밍이 예상과 다를 수 있습니다.
- 이로 인해 UI와 데이터 상태 간의 불일치가 발생할 수 있습니다.

1.3 성능 문제

- 많은 수의 액션이 빠르게 연속해서 발생하면, 각 액션마다 리듀서가 실행되고 상태가 업데이트되어 성능 저하를 일으킬 수 있습니다.

1.4 디버깅의 어려움

- 연속적인 액션으로 인해 상태 변화가 복잡해지면, 어떤 액션이 어떤 상태 변화를 일으켰는지 추적하기 어려워집니다.

1.5 불필요한 리액트 컴포넌트 리렌더링

- 각 액션마다 상태가 변경되면 연결된 React 컴포넌트들이 불필요하게 여러 번 리렌더링될 수 있습니다.

### 2. 해결 방법

2.1 액션 디스패치 조절

- 액션 발생 시점을 특정 조건에 맞게 조정합니다.
- 예: 버튼 클릭 시 디바운스(debounce) 기법 사용

```jsx
let timeout;

function handleButtonClick() {
  clearTimeout(timeout);
  timeout = setTimeout(() => {
    dispatch({ type: 'ACTION_TYPE' });
  }, 300);
}
```

2.2 액션 묶기 (Action Batching)

- 여러 개의 연관된 액션을 하나의 액션으로 묶어 디스패치합니다.
- Redux Toolkit의 `createAction` 함수를 활용할 수 있습니다.

```jsx
const complexAction = createAction('COMPLEX_ACTION', (data) => ({
  payload: {
    increment: data.increment,
    decrement: data.decrement,
// 기타 필요한 데이터
  }
}));

// 사용 예
dispatch(complexAction({ increment: 5, decrement: 3 }));
```

2.3 Redux-Saga 사용

- 복잡한 비동기 작업과 부수 효과를 관리하는 미들웨어입니다.
- 여러 액션을 순차적으로 또는 병렬로 처리할 수 있습니다.

```jsx
import { call, put, takeEvery } from 'redux-saga/effects';

function* handleComplexOperation() {
  yield put({ type: 'START_OPERATION' });
  try {
    const result = yield call(apiCall);
    yield put({ type: 'OPERATION_SUCCESS', payload: result });
  } catch (error) {
    yield put({ type: 'OPERATION_FAILURE', error });
  }
}

function* rootSaga() {
  yield takeEvery('COMPLEX_OPERATION', handleComplexOperation);
}
```

2.4 Thunk 미들웨어 사용

- Redux Thunk를 사용하면 액션 크리에이터가 함수를 반환할 수 있어, 비동기 로직을 포함한 복잡한 액션 시퀀스를 관리할 수 있습니다.

```jsx
const complexOperation = () => async (dispatch) => {
  dispatch({ type: 'START_OPERATION' });
  try {
    const result = await apiCall();
    dispatch({ type: 'OPERATION_SUCCESS', payload: result });
  } catch (error) {
    dispatch({ type: 'OPERATION_FAILURE', error });
  }
};

// 사용 예
dispatch(complexOperation());
```

<br>

## Serialize 할 수 없는 값은 리덕스 상태에 왜 넣지 말라고 하는 것인가요? 명확한 이유와 함께 본인 만의 예시를 이용해 설명해주세요.

- Serialize(직렬화)란?
    
    데이터 구조나 객체 상태를 저장하거나 전송할 수 있는 형태로 변환하는 과정을 말합니다.
    
    주로 복잡한 데이터 구조를 문자열이나 바이트 스트림 같은 단순한 형태로 변환하는 것을 의미합니다.
    

### serialize 할 수 없는 값을 넣지 말아야 하는 이유

1. 상태 지속성
    - 리덕스는 애플리케이션의 상태를 저장하고 관리하는데, 이 상태를 로컬 스토리지나 서버에 저장하여 나중에 복원할 수 있어야 합니다.
    - Serialize 할 수 없는 값은 이러한 저장 및 복원 과정에서 문제를 일으킵니다.
2. 시간 여행 디버깅
    - 리덕스의 강력한 기능 중 하나는 상태 변화를 시간별로 추적할 수 있는 것입니다.
    - Serialize 할 수 없는 값이 포함되면 이 기능이 제대로 작동하지 않습니다.
3. 상태 예측 가능성
    - 리덕스는 순수 함수와 불변성을 통해 상태의 예측 가능성을 보장합니다.
    - Serialize 할 수 없는 값은 이러한 원칙을 위반할 가능성이 높습니다.

### 본인 만의 예시

배열에 함수를 넣고 `JSON.stringify()`를 사용하는 것도 serialize의 한 예이며, 이 경우에도 serialize 불가능한 값으로 인한 문제가 발생합니다.

```jsx
const myArray = [
  1,
  "hello",
  { name: "Kim" },
  function() { console.log("Hi!"); }
];

console.log(JSON.stringify(myArray)); // [1,"hello",{"name":"Kim"},null]
```

1. 숫자, 문자열, 객체는 정상적으로 serialize 되었습니다.
2. 함수는 `null`로 변환되었습니다.
    
    이는 `JSON.stringify()`가 함수를 serialize할 수 없기 때문입니다.
    JSON 형식은 데이터를 표현하기 위한 것이며, 함수나 메서드와 같은 동작을 포함하지 않습니다.
    
    이러한 동작은 리덕스 상태 관리에서 문제를 일으킬 수 있습니다.
    
3. 함수가 `null`로 변환되어 원래의 기능을 잃게 됩니다.
4. 개발자가 상태에 함수가 있다고 예상하고 코드를 작성했다면, 이 함수가 `null`이 되어 예상치 못한 오류가 발생할 수 있습니다.
5. 시간 여행 디버깅 등의 기능을 사용할 때, 함수가 `null`로 표시되어 상태의 실제 내용을 정확히 파악하기 어려워집니다.

따라서 리덕스 상태에는 serialize 가능한 값(숫자, 문자열, 배열, 일반 객체 등)만을 저장하고, 함수나 복잡한 객체는 다른 방식으로 관리하는 것이 좋습니다.

예를 들어, 함수 대신 함수의 이름을 문자열로 저장하고, 필요할 때 해당 이름에 맞는 함수를 호출하는 방식을 사용할 수 있습니다.

<br>

## 상태 정규화란 무엇이고 왜 하는 것인가요? 명확한 이유와 함께 본인 만의 예시를 이용해 설명해주세요.

### 상태 정규화(State Normalization)란?

데이터베이스 설계 원칙에서 유래한 개념으로, 리덕스와 같은 상태 관리 시스템에서 데이터를 구조화하는 방법입니다.

주요 목적은 데이터의 중복을 줄이고 일관성을 유지하며 업데이트를 효율적으로 수행하는 것입니다.

### 상태 정규화를 하는 주요 이유

1. 같은 데이터가 여러 곳에 중복되어 저장되는 것을 방지합니다.
2. 한 곳에서 데이터를 업데이트하면 모든 관련 부분이 자동으로 업데이트 됩니다.
3. 데이터의 일관성을 쉽게 유지할 수 있습니다.
4. 필요한 데이터만 정확히 업데이트할 수 있어 성능이 향상됩니다.

### 예시

저는 옛날에 구글 캘린더와 유사한 프로젝트를 개발했습니다.

이 시스템에서 가장 중요한 기능 중 하나는 스케줄 관리였는데, 특히 새로운 스케줄을 등록할 때 이미 예약된 시간과 겹치지 않는지 빠르게 확인해야 했습니다.

처음에는 단순히 모든 스케줄을 배열로 저장하고, 새 스케줄을 추가할 때마다 전체 배열을 순회하며 충돌을 확인했습니다.

하지만 이 방식은 스케줄 수가 늘어날수록 점점 느려습니다.

이 문제를 해결하기 위해 상태 정규화를 적용했습니다. 구체적으로, 스케줄 데이터를 시간대별로 인덱싱하여 저장했습니다.

1. 날짜별 인덱스: 각 날짜를 키로 하고, 해당 날짜의 스케줄 ID 목록을 값으로 하는 객체를 만들었습니다.
2. 시간대별 인덱스: 각 시간대(예: 1시간 단위)를 키로 하고, 해당 시간대의 스케줄 ID 목록을 값으로 하는 객체를 만들었습니다.
3. 스케줄 상세 정보: 각 스케줄의 상세 정보는 별도의 객체에 ID를 키로 하여 저장했습니다.

이렇게 정규화된 구조 덕분에, 새 스케줄을 등록하기 전에 해당 시간대의 충돌을 확인하는 과정이 훨씬 빨라졌습니다.

전체 스케줄을 순회하는 대신, 특정 날짜와 시간대의 스케줄만을 빠르게 조회할 수 있게 되었기 때문입니다.

예를 들어, 2024년 3월 15일 14:00-15:00에 새 스케줄을 등록하려 할 때,

1. '2024-03-15' 키를 가진 날짜 인덱스를 확인
2. '14' 키를 가진 시간대 인덱스를 확인
3. 위에서 찾은 스케줄 ID들의 실제 시간을 상세 정보에서 확인하여 중복 여부 판단

이 방식으로 전체 스케줄의 수와 관계없이, 항상 일정한 시간 내에 충돌을 확인할 수 있게 되었습니다.

결과적으로 사용자들은 새 스케줄을 등록할 때 즉각적인 피드백을 받을 수 있었고, 시스템의 전반적인 성능과 사용자 경험이 크게 개선되었습니다."

<br>

## 리덕스의 스토어는 내부적으로 어떻게 상태 변경을 감지할까요? 이와 비슷한 패턴을 가진 다른 예시는 무엇이 있을까요? 여러분은 이런 패턴을 어떤 경우에 적용해볼 수 있을까요?

### 리덕스 스토어 내부 상태 변경 감지

리덕스의 스토어는 상태 변경을 직접 "감지"하는 것이 아니라, 액션이 디스패치될 때마다 상태가 변경될 수 있다고 가정합니다.

1. **액션 디스패치**
    - `store.dispatch(action)`을 호출하면 스토어는 현재 상태와 함께 해당 액션을 리듀서에 전달합니다.
2. **상태 업데이트**
    - 리듀서는 전달받은 상태와 액션을 기반으로 새로운 상태를 반환합니다.
3. **구독자 알림**
    - 스토어는 상태가 업데이트된 후, 등록된 모든 리스너(구독자) 함수를 호출하여 상태 변경을 알립니다.

이 과정에서 스토어는 상태의 이전 값과 새로운 값을 비교하지 않습니다.

대신, 액션이 디스패치되면 상태가 변경되었을 것으로 간주하고 구독자에게 알립니다.

이는 **퍼블리시-서브스크라이브(pub-sub) 패턴**을 활용한 것입니다.

- **옵저버 패턴(Observer Pattern)**: 객체가 변화할 때 이를 관찰자들에게 알리는 디자인 패턴으로, 구독자들이 주체의 상태 변화를 감지하고 대응합니다.
- **이벤트 리스너(Event Listener)**: JavaScript나 Node.js에서 사용되는 패턴으로, 특정 이벤트가 발생하면 등록된 콜백 함수들이 호출됩니다.
- **React의 상태 관리**: 컴포넌트의 상태가 변경되면 React는 자동으로 렌더링 과정을 트리거하여 UI를 업데이트합니다.

### 패턴 적용해보기

1. 웹 프론트엔드 개발
    - **React, Vue.js, Angular**: 이러한 프레임워크들은 컴포넌트 기반 아키텍처와 상태 관리를 위해 옵저버 패턴이나 퍼블리시-서브스크라이브 패턴을 활용합니다.
    - **상태 관리 라이브러리**: Redux, MobX 등은 애플리케이션의 상태 변화를 효율적으로 관리하기 위해 이러한 패턴을 사용합니다.
2. **모바일 앱 개발**
- **iOS의 NotificationCenter**: 앱 내에서 이벤트를 전달하고 구독하기 위해 옵저버 패턴을 사용합니다.
- **Android의 LiveData 및 RxJava**: 데이터의 변화를 관찰하고 UI에 반영하기 위해 리액티브 프로그래밍과 옵저버 패턴을 활용합니다.

