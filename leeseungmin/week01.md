# JavaScript


- EcmaScript와 JavaScript의 차이점은 무엇인가요?
    
    JavaScript는 EcmaScript 표준을 따르는 구현체이며 EcmaScript는 JavaScript의 기능을 정의하는 명세서라고 할 수 있습니다.
    
    주요 차이점
    
    - ECMAScript는 규격이고, JavaScript는 이 규격을 구현한 언어입니다.
    - JavaScript는 ECMAScript 외에도 브라우저 환경에서 사용할 수 있는 추가 기능을 포함합니다.
    - ECMAScript 버전이 업데이트되면 JavaScript도 새로운 기능을 구현합니다.
    
    ### ECMAScript
    
    - Ecma International에서 ECMA-262 기술 규격에 따라 정의한 표준화된 스크립트 프로그래밍 언어입니다.
    - 이는 언어의 핵심 기능과 문법을 정의합니다.
    - ES6, ES7 등 버전이 존재하며, 새로운 기능이 추가될 때마다 업그레이드됩니다.
    
    ### JavaScript
    
    - ECMAScript 사양을 기반으로 만들어진 실제 프로그래밍 언어입니다.
    - JavaScript는 ECMAScript의 기능을 포함하면서도 추가적인 기능(예: DOM 조작, 웹 API 등)을 제공합니다.
    - 브라우저와 호환되는 엔진(V8, SpiderMonkey 등)에 의해 동작합니다.
    
    <br>
    
    ---
    <br>    

- 자바스크립트의 자료형(타입)에는 어떤 것들이 있나요?
    
    기본(원시) 타입
    
    - Number: 숫자 (예: 42, 3.14)
    - String: 문자열 (예: "Hello", 'World')
    - Boolean: 논리값 (true 또는 false)
    - Undefined: 값이 할당되지 않은 상태
    - Null: 의도적으로 값이 없음을 나타내는 상태
    - Symbol: ES6에서 추가된 고유한 식별자 (예: Symbol('id'))
    - BigInt: ES11에서 추가된 큰 정수를 다루기 위한 타입 (예: 1234567890123456789n)
    
    객체 타입
    
    - Object: 키-값 쌍의 집합 (예: {name: "John", age: 30})
    - Array: 순서가 있는 값의 집합 (예: [1, 2, 3])
    - Function: 실행 가능한 코드 블록
    - Date: 날짜와 시간을 나타내는 객체
    - RegExp: 정규 표현식 객체(Regular Expression)
    - Map, Set

    <br>
    
    ---
    <br>

- Document Object Model이란 무엇인가요?

    > Document Object Model (DOM)은 웹 페이지의 구조화된 표현으로,HTML 또는 XML 문서를 트리 구조로 나타낸 것입니다.<br>각 요소는 노드(Node)로 표현되며, 자바스크립트와 같은 프로그래밍 언어를 사용해 문서의 내용이나 구조를 동적으로 변경할 수 있습니다.
    >
    주요 특징
    
    - **트리 구조**: DOM은 문서를 트리 구조로 나타내며, 각 노드는 부모-자식 관계를 가집니다.
    - **동적 수정**: DOM을 통해 웹 페이지의 요소를 동적으로 생성, 삭제, 수정할 수 있습니다.
    - **이벤트 처리**: DOM을 사용해 웹 페이지에서 발생하는 다양한 이벤트(클릭, 키보드 입력 등)를 처리할 수 있습니다.

    <br>
    
    ---
    <br>
    
- 이벤트 위임이란 무엇인가요? 이벤트 캡쳐링과 이벤트 버블링의 차이점은 무엇인가요?
    
    ### 이벤트 위임이란?
    
    > 이벤트 위임은 여러 요소에 대해 이벤트 핸들러를 개별적으로 추가하는 대신,
    상위 요소에 하나의 이벤트 핸들러를 추가하여 하위 요소들의 이벤트를 관리하는 기법입니다.
    이벤트가 버블링 또는 캡쳐링 단계에서 상위 요소까지 도달하기 때문에 상위 요소에서 이벤트를 잡아 처리할 수 있습니다.
    > 
    
    ### 장점
    
    - 메모리 사용량 감소
    - 동적으로 추가되는 요소들에 대해서도 이벤트 처리 가능
    - 코드의 간결성
    
    ### 이벤트 캡처링과 버블링의 차이점
    
    1. 전파방향
        - 이벤트 캡처링은 최상위 요소에서 시작하여, 이벤트가 발생한 요소까지 내려갑니다.
        - 이벤트 버블링은 이벤트가 발생한 요소에서 시작하여 최상위 요소로 올라갑니다.
    2. 실행 순서
        - 이벤트 캡처링이 먼저 발생하고 그다음 이벤트 버빌링이 발생합니다.
    3. 기본 동작
        - 대부분의 부라우저에서 이벤트 버블링이 기본 동작입니다.
        - 이벤트 캡처링을 사용하려면 명시적으로 설정해야 합니다.
    
    이벤트 캡처링
    
    - 이벤트가 최상위 부모 요소에서 시작해 목표 요소로 전파되는 단계입니다.
    - 이 과정에서 이벤트가 먼저 실행됩니다.
    
    이벤트 버블링
    
    - 반대로 이벤트가 목표 요소에서 시작해 상위 요소들로 전파되는 단계입니다.
    - 기본적으로 자바스크립트에서 이벤트는 버블링을 통해 전파됩니다.
    
    ### 이벤트 위임과, 이벤트 전파의 차이는?
    
    > 이벤트 위임은 이벤트 전파를 활용하여 특정한 문제를 해결하는 기법이며,
    이벤트 전파 자체는 모든 이벤트가 발생했을 때의 기본 동작입니다.
    > 
    
    ### **1. 이벤트 위임 (Event Delegation)**
    
    > 이벤트 위임은 하나 이상의 하위 요소들에 대한 이벤트 처리를 부모 요소에 맡기는 기법입니다.
    즉, 개별 하위 요소들에 각각 이벤트 리스너를 붙이는 대신,
    상위 부모 요소에 하나의 이벤트 리스너를 붙여 모든 하위 요소들의 이벤트를 처리할 수 있도록 합니다.
    > 
    - **장점**
        - **효율성**: 많은 하위 요소들이 있을 때, 각각에 이벤트 리스너를 붙이는 것보다 메모리 사용이 효율적입니다.
        - **유연성**: 동적으로 추가되거나 제거되는 요소들에 대해서도 별도의 이벤트 리스너를 추가하거나 제거할 필요 없이, 부모 요소의 이벤트 리스너 하나로 처리할 수 있습니다.
    - **작동 원리**: 이벤트 위임은 이벤트 전파(특히 버블링)를 활용합니다. 이벤트가 발생하면, 해당 이벤트가 하위 요소에서 상위 요소로 전파되기 때문에, 상위 요소에만 이벤트 리스너를 부착해도 하위 요소에서 발생하는 이벤트를 감지하고 처리할 수 있습니다.
    
    ### **2. 이벤트 전파 (Event Propagation)**
    
    - 이벤트 전파는 DOM 요소에서 발생한 이벤트가 트리를 따라 전파되는 과정을 의미합니다.
        1. **캡처링 단계**: 이벤트가 최상위 요소(document)에서 시작해 목표 요소로 전파되는 단계.
        2. **타겟 단계**: 이벤트가 실제로 목표 요소에 도달해 발생하는 단계.
        3. **버블링 단계**: 이벤트가 목표 요소에서 다시 최상위 요소로 전파되는 단계.
    - **이벤트 전파의 유형**
        - **캡처링(Capturing)**: 이벤트가 최상위 부모 요소부터 목표 요소로 내려가는 과정
        - **버블링(Bubbling)**: 이벤트가 목표 요소에서 시작해 부모 요소로 올라가는 과정
    
    ### **차이점**
    
    - **이벤트 위임**
        - 주로 효율적인 이벤트 처리와 코드 유지보수를 위해 사용됩니다.
        - 이벤트가 자주 발생하는 하위 요소들을 효율적으로 관리하기 위해 부모 요소에 이벤트 리스너를 부착합니다.
    - **이벤트 전파**
        - DOM 트리 내에서 이벤트가 어떻게 전파되는지를 설명하는 개념으로, 이벤트 위임의 기초가 됩니다.
    - **사용 방식**
        - **이벤트 위임**: 이벤트 리스너를 부모 요소에 부착하여 하위 요소들의 이벤트를 처리합니다.
        - **이벤트 전파**: 이벤트가 발생한 후, DOM 트리에서 상하로 전파되는 자연스러운 흐름을 설명합니다.

    <br>
    
    ---
    <br>
    
- event.target과 event.currentTarget의 차이점에 대해 설명해보세요.

    > event.target은 실제로 이벤트가 발생한 요소를 가리키고,<br>
    event.currentTarget은 이벤트 핸들러가 붙어있는 요소를 가리킵니다.<br>
    즉, 이벤트가 위임되었을 때, target은 이벤트가 발생한 하위 요소고, currentTarget은 이벤트를 듣고 있는 부모 요소입니다.
    >

    - **`event.target`**
        - 이벤트가 발생한 실제 요소를 가리킵니다.
        - 사용자가 클릭한 요소나 마우스를 올린 요소와 같이, 이벤트가 발생한 원래의 요소를 의미합니다.
    - **`event.currentTarget`**
        - 현재 이벤트가 처리 중인 요소를 가리킵니다.
        - 이벤트 리스너가 부착된 요소입니다.
        - `event.currentTarget`을 사용하여 이벤트 핸들러가 연결된 상위 요소를 참조할 수 있습니다.
        - `event.currentTarget`은 이벤트 핸들러 내부에서 `this`키워드와 동일한 값을 가집니다. (`this` 바인딩을 생성하지 않는 화살표 함수 제외)
    
    ```jsx
    // 예시
    <div id="outer">
      <div id="inner">
        <button id="button">Click me</button>
      </div>
    </div>
    
    <script>
    document.getElementById("outer").addEventListener("click", function(e) {
        console.log("Target:", e.target.id);
        console.log("CurrentTarget:", e.currentTarget.id);
    });
    </script>
    
    // 버튼 클릭시
    // e.target.id는 "button"
    // e.currentTarget.id는 "outer"
    ```

    <br>
    
    ---
    <br>
    
- Call by value와 Call by reference의 차이점은 무엇인가요?
    
    > Call by Value는 함수에 값을 복사해서 전달하기 때문에 함수 내에서 값이 변경되어도 원래 변수에는 아무런 영향이 없습니다. <br>
    Call by Reference는 변수의 참조(주소)를 전달하여, 함수 내에서 값이 변경되면 원래 변수에도 그 변경이 반영됩니다.
    >
    Call by value (값에 의한 호출)
    
    - 함수에 인자로 값의 복사본이 전달됩니다.
    - 원본 값은 변경되지 않습니다.
    - JavaScript에서 원시 타입(Number, String, Boolean 등)은 Call by value로 전달됩니다.
    
    ```jsx
    // 예시
    function changeValue(x) {
        x = 10;
    }
    
    let a = 5;
    changeValue(a);
    console.log(a);  // 출력: 5 (변경되지 않음)
    ```
    
    Call by reference (참조에 의한 호출)
    
    - 함수에 인자로 값의 메모리 주소(참조)가 전달됩니다.
    - 함수 내에서 인자를 변경하면 원본 값도 변경됩니다.
    - JavaScript에서 객체는 Call by reference와 유사하게 동작합니다.
    
    ```jsx
    // 예시
    function changeObject(obj) {
        obj.prop = 10;
    }
    
    let obj = {prop: 5};
    changeObject(obj);
    console.log(obj.prop);  // 출력: 10 (변경됨)
    ```
    
    JavaScript에서는 기본적으로 원시 타입(Primitive Type)은 **Call by Value**로 전달되고,
    객체와 배열과 같은 참조 타입(Reference Type)은 Call by Reference처럼 동작합니다.

    <br>


# React 


- 브라우저에 URL을 입력한 순간부터 화면에 웹 페이지가 나타나기까지의 모든 과정을 아는대로 최대한 자세히 설명해보세요.
    1. DNS 조회
        - 브라우저는 입력된 도메인 이름을 IP 주소로 변환합니다.
        - 로컬 DNS 캐시 확인 후, 필요시 ISP의 DNS 서버에 요청을 보냅니다.
    2. TCP 연결 수립
        - 얻은 IP 주소로 웹 서버와 TCP 연결을 시도합니다.
            - **3-way handshake** 과정을 통해 연결이 수립됩니다 (SYN, SYN-ACK, ACK).
    3. TLS 핸드셰이크 (HTTPS의 경우)
        - 보안 연결이 필요한 경우 TLS 핸드셰이크가 진행됩니다.
            - 서버의 인증서 확인, 암호화 방식 협상 등이 포함됩니다.
    4. HTTP 요청 전송
        - 브라우저가 서버에 HTTP GET 요청을 보냅니다.
            - 요청 헤더에는 브라우저 정보, 수용 가능한 콘텐츠 유형 등이 포함됩니다.
    5. 서버 처리 및 HTTP 응답
        - 서버는 요청을 처리하고 HTML 문서를 포함한 HTTP 응답을 보냅니다.
            - 정적 콘텐츠의 경우 파일을 직접 전송하고, 동적 콘텐츠의 경우 **서버 사이드 스크립트**(예: PHP, Python, Java 등)를 실행하여 콘텐츠를 생성합니다.
            - 응답에는 상태 코드(예: 200 OK), 헤더, 그리고 HTML 문서가 포함됩니다.
    6. HTML 파싱 및 DOM 트리 생성
        - 브라우저는 HTML을 파싱하여 DOM 트리를 구성합니다.
    7. CSS 처리 및 CSSOM 생성
        - CSS 파일을 다운로드하고 파싱하여 CSSOM을 생성합니다
    8. 자바스크립트 실행
        - HTML 파서가 `<script>` 태그를 만나면 자바스크립트 코드를 실행합니다.
        - 자바스크립트는 DOM을 조작하거나 AJAX 요청을 보낼 수 있습니다.
    9. 렌더 트리 구축
        - DOM과 CSSOM을 결합하여 **렌더 트리**를 만듭니다.
    10. 레이아웃
        - 렌더 트리의 각 노드에 대해 화면상의 정확한 위치와 크기를 계산합니다.
    11. 페인팅
        - 레이아웃 정보를 바탕으로 실제 픽셀을 화면에 그립니다.

    <br>
    
    ---
    <br>
    
- `package.json`, `package-lock.json`, `node_modules`는 무엇인가요?
    
    1. `package.json` 
        - Node.js 프로젝트의 메타데이터를 담고 있는 JSON 파일입니다.
        - 프로젝트 이름, 버전, 설명, 의존성 패키지 목록 등을 포함합니다.
        - `npm init` 명령어로 생성할 수 있습니다.
    2. `package-lock.json`
        - 프로젝트의 의존성 트리를 정확히 기록한 파일입니다.
        - 각 패키지의 정확한 버전과 하위 의존성을 명시합니다.
        - 다른 개발 환경에서도 동일한 의존성 구조를 재현할 수 있게 합니다.
    3. `node_modules`
        - 프로젝트의 의존성 패키지들이 실제로 설치되는 디렉토리입니다.
        - `npm install` 명령어를 실행하면 이 폴더에 패키지들이 다운로드됩니다.
        - 보통 버전 관리 시스템(.gitignore 등)에서 제외됩니다.

    ### `package.json` 와 `package-lock.json` 의 차이점
    
    1. 버전 관리
        
        package.json
        
        - 보통 ^나 ~와 같은 버전 범위 지정자를 사용합니다.
        - 예: "express": "^4.17.1"는 4.17.1 이상 5.0.0 미만의 버전을 허용합니다.
        
        package-lock.json
        
        - 정확한 버전 번호를 지정합니다.
        - 예: "express": "4.17.1"와 같이 정확한 버전을 명시합니다.
    2. 의존성 해결
        
        package.json
        
        - npm install 실행 시 허용 가능한 버전 범위 내에서 최신 버전을 설치합니다.
        - 이로 인해 같은 package.json으로 다른 환경에서 설치할 때 다른 버전이 설치될 수 있습니다.
        
        package-lock.json
        
        - 정확히 동일한 의존성 트리를 재현할 수 있게 합니다.
        - 모든 개발자와 배포 환경에서 일관된 패키지 버전을 사용할 수 있게 합니다.
    3. 버전 관리 시스템에서의 역할
        
        package.json
        
        - 항상 버전 관리 시스템(예: Git)에 포함되어야 합니다.
        
        package-lock.json
        
        - 일반적으로 버전 관리 시스템에 포함됩니다.
        - 팀 프로젝트에서 일관된 의존성을 유지하는 데 중요합니다.
    
    ### npm install 명령어를 실행할 때 일어나는 과정
    
    1. npm은 먼저 프로젝트의 package.json 파일을 읽습니다.
    2. package.json에 명시된 의존성 패키지들의 정보를 확인합니다.
    3. 이 정보를 바탕으로 필요한 패키지들을 npm 레지스트리에서 다운로드합니다.
    4. 다운로드한 패키지들을 node_modules 디렉토리에 설치합니다.
    
    "npm install 명령어를 실행하면, package.json에 명시된 의존성을 기준으로 필요한 패키지들을 다운로드받아 node_modules 폴더에 저장합니다."
    
    즉, node_modules는 패키지들이 실제로 저장되는 목적지이고, package.json은 어떤 패키지들을 설치해야 하는지에 대한 '명세서' 역할을 합니다.
    
    추가로 알아두면 좋을 점
    
    - 만약 package-lock.json 파일이 있다면, npm은 이 파일을 참조하여 정확한 버전의 패키지들을 설치합니다.
    - node_modules 폴더가 이미 존재하는 경우, npm은 필요한 패키지만 추가하거나 업데이트합니다.

    <br>
    
    ---
    <br>
- Client Side Rendering이란 무엇인가요?
    
    > Client Side Rendering (CSR)은 웹 페이지의 콘텐츠가 서버가 아니라 클라이언트(브라우저)에서 렌더링되는 방식입니다.
    >

    - 웹 애플리케이션의 렌더링을 클라이언트(브라우저) 측에서 수행하는 방식입니다.
    - 서버는 최소한의 HTML과 JavaScript 파일만 제공합니다.
    - 클라이언트는 JavaScript를 실행하여 필요한 데이터를 서버로부터 추가 요청하고,
    이를 바탕으로 페이지를 동적으로 구성합니다.
    - JavaScript가 브라우저에서 실행되면서 동적으로 콘텐츠를 생성하고 DOM을 조작합니다.
    - 초기 로딩 시간이 길 수 있지만, 이후 페이지 전환이 빠릅니다.
    - 서버 부하를 줄일 수 있고, 사용자 경험이 향상될 수 있습니다.
    - SEO(검색 엔진 최적화)에 불리할 수 있습니다.
    - CSR은 SPA(Single Page Application)와 함께 자주 사용되며, 
    페이지 간 빠른 전환과 비동기 데이터 로딩을 가능하게 합니다. 
    그러나 초기 로드 시간이 길어질 수 있다는 단점이 있습니다.
 
    <br>
    
    ---
    <br>
    
- Single Page Application이란 무엇인가요?
    
    > 웹 애플리케이션이 단일 HTML 페이지로 구성되어 있고, 페이지 전환이 전체 페이지를 새로고침하는 것이 아니라 동적으로 이루어지는 애플리케이션입니다.
    >
    - 하나의 HTML 페이지로 구성된 웹 애플리케이션입니다.
    - 초기 로드 시 모든 HTML, CSS, JavaScript를 로드하고,
    이후 사용자가 인터랙션할 때 필요한 데이터만 서버에서 비동기적으로 받아와서 DOM을 갱신합니다.
    - 브라우저 내에서 동적으로 콘텐츠를 업데이트하기 때문에 사용자 경험이 더 매끄럽고 응답성이 좋습니다.
    - 라우팅, 상태 관리 등을 클라이언트 측에서 처리합니다.
    - SPA의 대표적인 프레임워크로는 React, Angular, Vue.js 등이 있습니다.

    <br>
    
    ---
    <br>

- 상태 변화에 대해 React는 어떻게 반응할까요?
    
    **React**는 상태가 변경되었을 때 UI를 다시 렌더링하여 사용자가 항상 최신의 UI를 볼 수 있도록 합니다.
    
    > React 컴포넌트 내에서 상태(State)는 `useState`와 같은 훅을 사용하여 관리됩니다.
    상태가 변경되면 React는 자동으로 해당 컴포넌트를 다시 렌더링합니다.
    > 
    
    > React는 효율적인 렌더링을 위해 **Virtual DOM**을 사용합니다.
    상태 변화에 따라 변경된 부분만 Virtual DOM에서 업데이트한 후, 실제 DOM과 비교하여 차이점만을 반영합니다.
    이를 통해 최소한의 DOM 조작으로 빠르고 효율적인 업데이트가 가능합니다.
    > 
    
    ### React의 상태 변화 반응
    
    1. 상태 업데이트 감지
        - React 컴포넌트의 state나 props가 변경되면 React는 이를 감지합니다.
    2. 재조정(Reconciliation) 과정
        - 가상 DOM(Virtual DOM)에 새로운 요소 트리를 생성합니다.
        - 이전 가상 DOM과 새로운 가상 DOM을 비교합니다.
    3. 차이점 식별
        - 두 가상 DOM 트리의 차이를 찾아냅니다.
    4. 실제 DOM 업데이트
        - 필요한 부분만 실제 DOM에 적용합니다.
    5. 렌더링
        - 변경된 부분만 화면에 다시 그립니다.
    
    ### 결론
    
    이 과정을 통해 React는 효율적으로 UI를 업데이트하며, 불필요한 DOM 조작을 최소화합니다.
    
    <br>
    
    ---
    <br>
    
- 리액트의 Strict Mode는 어떤 역할을 하는 것인지 최대한 자세히 설명해보세요.
    > React의 Strict Mode는 개발 모드에서 사용되는 도구로,<br>
    잠재적인 문제를 감지하고 개발 과정에서 더 나은 품질의 코드를 작성하도록 돕기 위해 제공되는 기능입니다.
    >
    - **주요 기능**
        - **안전하지 않은 생명 주기 메서드**
            - 비권장되는 생명 주기 메서드의 사용을 감지하여 경고를 표시합니다.
        - **의도치 않은 사이드 이펙트 감지**
            - 예를 들어, 예상치 못한 부작용이 발생할 수 있는 부분을 감지하여 개발자가 문제를 사전에 해결할 수 있도록 합니다.
        - **비동기 처리 문제 감지**
            - 비동기 작업이 의도한 대로 동작하지 않을 때 경고를 제공합니다.
        - 예기치 않은 부작용 검사
            - 일부 생명주기 메서드를 이중으로 호출하여 부작용을 찾아냅니다.
        - **중복 선언 검사**
            - 동일한 키를 가진 중복된 요소가 있을 경우 경고를 표시합니다.
        - 레거시 문자열 ref 사용 경고
            - 문자열 ref 대신 함수형 ref나 createRef를 사용하도록 권장합니다.
        - 메모리 누수 감지
            - useEffect 클린업 함수의 누락을 감지합니다.
        
        Strict Mode는 개발 환경에서만 동작하며, 프로덕션 환경에서는 아무런 영향을 미치지 않습니다. 이는 `<React.StrictMode>` 태그로 감쌀 수 있습니다.