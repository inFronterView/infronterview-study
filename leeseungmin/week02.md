## JavaScript

- `var`, `let`, `const`의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.
    - **`var`**
        - **특징**
            - ES5에서 도입된 `var`은 함수 레벨 스코프를 갖습니다. 이는 `var`로 선언된 변수가 함수 내부 어디에서나 접근 가능하다는 의미입니다.
            - 호이스팅(hoisting) 현상이 있어 변수 선언이 코드의 최상단으로 끌어올려지는 것처럼 작동합니다.
        - **문제점**: `var`은 블록 레벨 스코프를 지원하지 않으므로 의도치 않게 변수가 덮어씌워지거나 누락될 수 있습니다.
        - **사용 컨벤션**: 새로운 코드에서는 `var` 대신 `let`과 `const`를 사용하는 것이 권장됩니다.
    - **`let`**
        - **특징**
            - ES6에서 도입된 `let`은 블록 레벨 스코프를 갖습니다. 이는 변수가 선언된 블록 내에서만 접근할 수 있음을 의미합니다.
            - 호이스팅되지만 초기화되지 않은 상태로 존재하므로 참조 에러를 발생시킬 수 있습니다.
        - **용도**: 변수의 값이 변경될 가능성이 있는 경우에 `let`을 사용하는 것이 적절합니다.
    - **`const`**
        - **특징**
            - ES6에서 도입된 `const`는 블록 레벨 스코프를 갖습니다. 상수 값을 정의할 때 사용되며, 선언과 동시에 초기화가 필요합니다.
            - `const`로 선언된 변수는 재할당이 불가능하지만, 객체나 배열의 경우 내용물은 변경이 가능합니다.
        - **용도**: 값이 변하지 않는 상수 값을 정의할 때 사용합니다.
    - **사용 컨벤션**
        - 기본적으로 `let`과 `const`를 사용하고, 값이 변하지 않는 경우에는 `const`를, 값이 변할 가능성이 있는 경우에는 `let`을 사용하는 것이 좋습니다.
        - `var`는 기존 코드와의 호환성을 위해 사용하는 경우를 제외하고는 지양하는 것이 바람직합니다.

<br>

---
<br>

- 자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?
    
    ### 스레드란?
    
    > 프로세스 내에서 독립적으로 실행되는 작업단위 입니다.
    스레드는 프로그램의 실행 흐름을 처리하며, 각 스레드는 자체적으로 코드 실행, 스택, 레지스터 등을 갖고 있습니다.
    > 
    - 스레드의 역할
        - 병렬처리: 여러 스레드를 사용하여 동시에 여러 작업을 처리할 수 있습니다.
        - 경량 프로세스: 스레드는 프로세스 내에서 실행되므로 메모리 사용이 적고, 생성과 전환이 빠릅니다.
    - 스레드의 특징
        - 독립 실행: 각 스레드는 독립적으로 실행되지만, 같은 프로세스 내에서 자원(메모리 등)을 공유합니다.
        - 컨텍스트 전환: 스레드 간의 전환은 빠르지만, 컨텍스트 전환이 빈번할 경우 성능에 영향을 미칠 수 있습니다.
    
    ### 자바스크립트의 스레드 모델
    
    > **자바스크립트는 기본적으로 싱글 스레드**로 동작합니다.
    즉, 자바스크립트는 한 번에 하나의 작업만 처리할 수 있습니다.
    > 
    - **이벤트 루프**
        - 자바스크립트는 이벤트 루프를 사용하여 비동기 작업을 처리합니다.
        - 비동기 작업은 작업이 완료되면 이벤트 루프에 의해 큐에서 처리됩니다.
    - **호이스팅과 비동기 처리**
        - 자바스크립트는 함수 호출, 변수 선언 등에서 호이스팅을 지원하며, 비동기 작업(예: 네트워크 요청, 타이머 등)은 콜백 큐에 추가되어 나중에 처리됩니다.
    
    ### 브라우저의 스레드 모델
    
    > **브라우저는 싱글 스레드**로 자바스크립트를 실행하지만, 전체 브라우저의 아키텍처는 멀티 스레드를 사용합니다.
    > 
    - **메인 스레드**: 자바스크립트 코드와 DOM 렌더링을 처리합니다. 이 메인 스레드는 싱글 스레드로 동작합니다.
    - **다른 스레드**
        - **렌더링 스레드**: 페이지의 렌더링, 레이아웃 계산 등을 담당합니다.
        - **네트워크 스레드**: 네트워크 요청과 응답을 처리합니다.
        - **웹 워커(Web Worker)**: 별도의 스레드에서 자바스크립트를 실행하여 메인 스레드의 부하를 줄입니다.

<br>

---
<br>

- 자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?
    
    **고차함수(Higher-Order Function)**
    
    > 다른 함수를 인자로 받거나, 함수를 반환하는 함수입니다.
    > 
    - **장점**
        - **추상화**: 코드의 중복을 줄이고, 공통된 로직을 재사용할 수 있습니다.
        - **유연성**: 동작을 인자로 전달하여 함수를 유연하게 조정할 수 있습니다.
        - **함수형 프로그래밍 지원**: 함수형 프로그래밍 패러다임을 지원하여 순수 함수와 불변성을 장려합니다.

- 자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.
    - **작동방식**
        
        > **`try` 블록**: 예외가 발생할 수 있는 코드를 작성합니다.<br>
        **`catch` 블록**: 예외가 발생했을 때 실행되는 코드를 작성합니다.<br>
        **`finally` 블록**: 예외 발생 여부와 관계없이 항상 실행되는 코드를 작성합니다(선택적).
        > 
        
    - 사용해야 하는 경우
        1. 외부 리소스 접근: API 호출, 파일 읽기/쓰기 등 실패 가능성이 있는 작업
        2. 사용자 입력 처리: 잘못된 형식의 데이터 입력에 대비
        3. 타입 변환: 숫자로 변환할 수 없는 문자열 처리 등
        4. 비동기 작업: Promise 기반 코드에서 오류 처리
        5. 라이브러리/모듈 사용: 외부 코드에서 발생할 수 있는 예기치 않은 오류 처리

<br>

---
<br>

- 프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.
    
    > 프러미스는 비동기 작업의 완료 또는 실패를 처리하는 객체입니다.<br>
    성공 시 `resolve`, 실패 시 `reject`를 호출하여 비동기 작업의 결과를 처리할 수 있습니다.<br>
    > 
    
    > 콜백 지옥(callback hell)을 방지하고, 체이닝(chaining)을 통해 비동기 작업을 직관적으로 처리할 수 있습니다.<br>
    `catch`를 사용하여 비동기 작업에서 발생한 에러를 처리할 수 있습니다.<br>
    여러 비동기 작업을 동시에 실행하고, 모든 작업이 완료된 후 결과를 처리하는 기능을 제공합니다.<br>
    >

<br>

---
<br>

- 자바스크립트의 Strict Mode에 대해 설명해보세요.
    
    > 자바스크립트의 엄격한 모드로, 코드의 오류를 더 엄격하게 검사하고,<br>
    일부 기능을 비활성화하여 보다 안전하고 예측 가능한 코드를 작성할 수 있도록 합니다.
    > 
    - **특징**
        - **엄격한 문법**
            - 예를 들어, 변수의 선언 없이 사용된 변수는 오류를 발생시킵니다.
            - **`this`의 문제**: 함수 내에서 `this`가 `undefined`로 설정되며, 더 명확한 컨텍스트를 요구합니다.
            - 함수 선언은 스크립트나 함수의 최상위 레벨에서만 허용됩니다.
        - **금지된 구문**: 예약어 사용을 금지하는 등 특정 구문을 제한합니다.

<br>

---
<br>

- 렉시컬 환경과 렉시컬 스코프란 무엇인가요?
    
    > 렉시컬 환경(Lexical Environment)은 자바스크립트에서 코드 실행 시 변수를 저장하고 관리하는 구조입니다. <br>
    각 함수나 블록이 실행될 때 렉시컬 환경이 생성되며, 변수와 함수 선언을 포함한 환경 레코드와 외부 스코프에 대한 참조를 갖습니다.
    > 
    
    > 렉시컬 스코프(Lexical Scope)는 자바스크립트에서 함수가 정의된 위치에 따라 변수 접근 범위가 결정되는 규칙을 의미합니다. <br>
    함수가 어디에서 호출되든 상관없이, 함수가 정의된 위치에 따라 스코프가 고정되어, 해당 위치에서 참조 가능한 변수들만 접근할 수 있습니다.
    > 
    1. 렉시컬 환경 (Lexical Environment)
        - 변수와 그 값을 저장하는 환경 레코드(Environment Record)입니다.
        - 외부 환경에 대한 참조를 포함합니다.
        - 코드의 중첩 구조를 반영하여 계층적으로 구성됩니다.
    2. 렉시컬 스코프 (Lexical Scope)
        - 함수나 변수가 선언된 위치에 따라 접근 가능한 범위가 결정됩니다.
        - 내부 함수에서 외부 함수나 전역 스코프의 변수에 접근 가능합니다.
        - 코드 작성 시점에 결정되며, 런타임에 변경되지 않습니다.
            - 렉시컬 스코프는 정적 스코프의 한 형태입니다.
                - 정적 스코프: 코드가 작성된 시점에 스코프가 결정됨
                - 동적 스코프: 코드가 실행되는 시점에 스코프가 결정됨

<br>

---
<br>

- `0.1 + 0.2 === 0.3`는 왜 `false`인가요?
    
    > **`0.1`과 `0.2`가 이진수로 정확하게 표현될 수 없기 때문에 `0.1 + 0.2`가 `0.3`과 정확히 일치하지 않는 것입니다.** <br>
    자바스크립트를 포함한 대부분의 프로그래밍 언어는 숫자를 IEEE 754 표준에 따라 부동 소수점으로 표현합니다.
    > 
    
    ### 부동 소수점이란 ?
    
    > 부동 소수점(floating point)은 컴퓨터에서 실수를 표현하는 방법입니다.
    숫자의 크기와 소수점을 동적으로 조정할 수 있어 매우 큰 숫자나 매우 작은 숫자를 표현할 수 있습니다.
    부동 소수점 표현은 컴퓨터가 숫자를 처리하고 계산할 때 일반적으로 사용됩니다.
    > 
    
    이 표준은 숫자를 이진수로 변환하여 표현하며, 이진수 표현에는 몇 가지 제한이 있습니다.
    
    ### 부동 소수점의 문제점
    
    - **정확도 제한**: 유한한 비트 수로 소수를 표현하기 때문에 정확한 값으로 표현할 수 없는 경우가 많습니다.
    - **근사치 오류**: 일부 연산 결과가 근사치로 표현되며, 이로 인해 예기치 않은 오류가 발생할 수 있습니다.
    
    ### 부동 소수점 숫자의 이진수 표현
    
    1. **부동 소수점 표현 방식**
        - 부동 소수점 숫자는 **부호**, **지수**, 가수(맨틱)의 세 부분으로 나뉩니다.
            - 가수란?
                - 정의: 실제 숫자의 유효 숫자를 나타내는 부분입니다.
                - 특징
                    - 보통 1과 2 사이의 값으로 정규화됩니다.
                    - 소수점 이하의 정밀도를 결정합니다.
                - 역할: 숫자의 '중요한' 부분을 저장합니다.
                - 예시: 123.45를 1.2345 × 10^2로 표현할 때, 1.2345가 가수입니다.
                - 중요성: 숫자의 정확도를 결정하는 핵심 요소입니다.
        - **부호**는 숫자의 양수 또는 음수를 나타냅니다.
        - **지수**는 숫자의 크기를 조정하는 데 사용됩니다.
        - **가수**는 숫자의 실제 값을 나타냅니다.
    2. **10진수를 이진수로 변환**
        - 10진수로 표현된 숫자는 이진수로 변환될 때 정확히 표현할 수 없는 경우가 많습니다. 
        특히 소수점 이하의 숫자는 이진수로 표현할 수 있는 비트 수에 의해 근사치로 표현됩니다.
    
    ### `0.1`과 `0.2`의 이진수 표현
    
    1. **`0.1`의 이진수 표현**
        - 0.1을 이진수로 변환하면, 0.1 = 0.0001100110011001100110011001100110011...과 같이 이진수로 무한히 반복됩니다.
        - 이진수로 표현하기에는 비트 수가 한정되어 있어 정확한 값을 나타낼 수 없습니다.
    2. **`0.2`의 이진수 표현**
        - 0.2를 이진수로 변환하면, 0.2 = 0.0011001100110011001100110011001100110011...과 같이 역시 무한히 반복됩니다.
        - 따라서 정확한 값을 이진수로 표현하기 어려워 근사치로 저장됩니다.
    
    ### 근사값의 결과
    
    - `0.1`과 `0.2`를 더하면, 실제로 자바스크립트에서 계산된 결과는 `0.30000000000000004`입니다.
    이는 이진수로 표현된 `0.1`과 `0.2`가 정확히 `0.3`이 되지 않기 때문입니다.
    
    ### `0.1 + 0.2 === 0.3`의 비교 문제
    
    - **정확하지 않은 비교**: `0.1 + 0.2`는 `0.30000000000000004`로 계산되며, 이는 `0.3`과 정확히 일치하지 않습니다.
    - **결과**: 이로 인해 `0.1 + 0.2 === 0.3`는 `false`를 반환합니다.
    
    ### 해결 방법
    
    - 소수점을 정수로 변환하여 비교할 수도 있습니다.

# React

- 리액트의 상태 끌어올리기는 어떤 단점이 있을까요?
    
    > 상태 끌어올리기의 단점은 복잡도 증가, 불필요한 렌더링, 재사용성 감소입니다.
    > 
    - 복잡도 증가
        - 상태를 부모 컴포넌트로 끌어올리면, 부모 컴포넌트가 더 많은 책임을 지게 됩니다. 
        이는 부모 컴포넌트의 코드가 복잡해지고 관리하기 어려워질 수 있음을 의미합니다.
        - 여러 자식 컴포넌트가 상태를 공유할 때, 상태와 관련된 로직이 중앙에서 관리되어야 하기 때문에 코드의 가독성이 떨어질 수 있습니다.
    - 불필요한 렌더링
        - 부모 컴포넌트의 상태가 변경되면, 그 부모와 모든 자식 컴포넌트가 다시 렌더링될 수 있습니다.
        이로 인해 성능 저하가 발생할 수 있으며, 불필요한 렌더링이 성능에 영향을 미칠 수 있습니다.
    - 재사용성 감소
        - 상태를 중앙에서 관리하게 되면, 해당 상태와 관련된 로직이 특정 컴포넌트에 강하게 결합됩니다. 
        이로 인해 컴포넌트의 재사용성이 떨어질 수 있으며, 다양한 상황에서 재사용하기 어려워질 수 있습니다.

<br>

---
<br>

- 가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?
    
    ### 가상 DOM(Virtual DOM)란?
    
    > 실제 브라우저의 DOM(Document Object Model)을 추상화한 JavaScript 객체의 표현입니다.<br>
    이는 메모리에 존재하는 가벼운 복사본으로, 실제 DOM의 구조를 모방합니다.
    > 
    
    ### 장점
    
    - **성능 향상**: 가상 돔은 실제 DOM을 직접 조작하는 대신 메모리 상에서 가벼운 돔을 조작합니다. 이를 통해 DOM 업데이트의 성능을 개선할 수 있습니다.
    - **효율적인 업데이트**: 가상 돔은 변경된 부분만을 비교하여 최소한의 실제 DOM 업데이트를 수행합니다. 이로 인해 전체 페이지의 렌더링 성능이 최적화됩니다.
    
    ### 단점
    
    - **추가 메모리 사용**: 가상 돔을 유지하기 위해 추가 메모리가 필요합니다. 이는 메모리 사용량이 증가하는 원인이 됩니다.
    - **추가 오버헤드**: 가상 돔과 실제 DOM을 비교하는 과정에서 약간의 성능 오버헤드가 발생할 수 있습니다. 이는 리액트의 diffing 알고리즘에 따른 것입니다.

<br>

---
<br>

- 리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.
    
    > Diffing Algorithm은 가상 DOM 트리의 변경사항을 효율적으로 감지하는 알고리즘입니다.
    > 
    
    ### 주요 단계
    
    1. 루트 엘리먼트부터 비교를 시작합니다.
    2. 엘리먼트 타입이 다르면 전체 서브트리를 교체합니다.
    3. 같은 타입의 DOM 엘리먼트는 속성만 업데이트합니다.
    4. 컴포넌트 인스턴스가 같으면 상태를 유지하고 props만 업데이트합니다.
    5. 자식 엘리먼트들을 재귀적으로 비교합니다.
    6. 리스트를 비교할 때는 key를 사용하여 효율적으로 식별합니다.
        - 빠른 비교 연산
            - React는 key를 사용하여 O(1) 시간 복잡도로 이전 렌더링과 현재 렌더링의 요소를 매칭합니다.
            - key가 없다면, React는 전체 리스트를 순회하며 비교해야 할 수 있습니다 (O(n) 시간 복잡도).
        - 최소한의 DOM 조작
            - 고유한 key를 통해 React는 실제로 변경된 요소만 정확히 식별할 수 있습니다.
            - 이를 통해 불필요한 DOM 조작을 최소화하고, 실제로 필요한 업데이트만 수행합니다.
        - 요소 재사용
            - key를 통해 React는 이전 렌더링의 요소와 현재 렌더링의 요소가 같은지 빠르게 판단할 수 있습니다.
            - 같은 key를 가진 요소는 가능한 한 재사용되어, 불필요한 리렌더링을 방지합니다.
        - 순서 변경 최적화
            - key를 사용하면 리스트의 순서가 변경되었을 때, 전체 리스트를 다시 렌더링하지 않고 변경된 위치만 업데이트할 수 있습니다.
    
    위의 과정을 통해 최소한의 DOM 조작으로 UI를 업데이트합니다.

<br>

---
<br>

- 리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?
    
    ### 무슨 뜻인가요?
    
    > 리액트에서 상태를 업데이트할 때, 호출된 상태 업데이트 함수는 즉시 상태를 새값으로 변경하지 않습니다.<br>
    대신, 업데이트 요청은 내부 큐에 저장되며, 이 큐는 비동기적으로 처리됩니다.<br>
    즉, 상태의 실제 변경은 현재 렌더링 사이클이 끝나고, 다음 렌더링 사이클에서 이루어집니다.<br>
    이로 인해 상태 업데이트 요청이 곧바로 반영되지 않고, 상태값이 새로운 값으로 업데이트되는 데 시간이 걸립니다.
    > 
    
    ### 왜 그럴까요?
    
    1. 성능 최적화
        - 비동기 상태 업데이트를 통해 리액트는 여러 상태 변경 요청을 하나의 배치로 처리할 수 있습니다.
        즉, 상태 업데이트가 일어날 때마다 바로 렌더링을 하지 않고, 여러 업데이트를 한 번에 처리하여 렌더링 횟수를 줄입니다.
        이렇게 함으로써 렌더링 성능을 개선하고 불필요한 렌더링을 방지합니다.
    2. 일관성 유지
        - 비동기 처리는 상태 업데이트의 일관성을 유지하는데 도움을 줍니다.
        - 상태가 동기적으로 처리되면, 연속적인 상태 변경이 서로 영향을미치거나 예상치 못한 결과를 초래할 수 있습니다.
        - 비동기적으로 처리하면 상태 변경 예측이 가능하고 일관되게 이루어지며, 예상되는 동작을 보장합니다.
    
    따라서 비동기 상태 업데이트는 성능을 최적화하고 상태 변경의 일관성을 보장하기 위해 리액트의 설계에 포함된 것입니다.

<br>

---
<br>

- 리액트 컴포넌트 내부에서 모든 함수를 `useCallback`으로 감싸는 것이 좋을까요?
    
    > **`useCallback`을 모든 함수에 적용하는 것은 좋지 않으며, 필요한 경우에만 사용하는 것이 바람직합니다.**
    > 
    - **장점**
        - `useCallback`은 함수가 재생성되는 것을 방지하여 성능을 최적화할 수 있습니다.
        - 자식 컴포넌트에 콜백 함수를 전달할 때 유용합니다.
    - **단점**
        - 모든 함수에 `useCallback`을 적용하면 코드가 복잡해질 수 있으며, 불필요한 메모이제이션이 오히려 성능에 부정적인 영향을 미칠 수 있습니다.
        - 의존성 배열을 잘못 설정하면 함수가 의도치 않게 변경되거나 동작이 예상과 다르게 될 수 있습니다.
