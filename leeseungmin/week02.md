# 목차

- JavaScript
  - [var, let, const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.](#var-let-const의-차이점-그리고-사용-컨벤션에-대해-최대한-자세히-설명해보세요)
  - [자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?](#자바스크립트는-싱글-스레드라고-합니다-스레드란-무엇인가요-브라우저도-싱글-스레드일까요)
  - [자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?](#자바스크립트에는-다양한-고차함수-형식의-메소드가-있습니다-고차함수의-장점은-무엇일까요)
  - [자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.](#자바스크립트의-trycatch의-기본적인-작동방식-그리고-언제-어떤-경우에-사용해야-하는지-조사해보세요)
  - [프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.](#프러미스를-사용하는-이유는-무엇인지-최대한-자세히-설명해보세요)
  - [자바스크립트의 Strict Mode에 대해 설명해보세요.](#자바스크립트의-strict-mode에-대해-설명해보세요)
  - [렉시컬 환경과 렉시컬 스코프란 무엇인가요?](#렉시컬-환경과-렉시컬-스코프란-무엇인가요)
  - [0.1 + 0.2 === 0.3는 왜 false인가요?](#01--02--03는-왜-false인가요)
- React
  - [리액트의 상태 끌어올리기는 어떤 단점이 있을까요?](#리액트의-상태-끌어올리기는-어떤-단점이-있을까요)
  - [가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?](#가상돔이라는-존재는-무엇이며-장점과-단점은-어떤-것들이-있을까요)
  - [리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.](#리액트의-diffing-algorithm의-내부-로직에-대해서-최대한-자세히-설명해보세요)
  - [리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?](#리액트의-상태-업데이트는-비동기로-실행됩니다-이-말은-무슨-뜻이며-왜-그럴까요)
  - [리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?](#리액트-컴포넌트-내부에서-모든-함수를-usecallback으로-감싸는-것이-좋을까요)

<br>

# Javascript

## var, let, const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.

- **`var`**
  - ES5에서 도입된 `var`은 함수 레벨 스코프를 갖습니다. 이는 `var`로 선언된 변수가 함수 내부 어디에서나 접근 가능하다는 의미입니다.
  - 호이스팅(hoisting) 현상이 있어 변수 선언이 코드의 최상단으로 끌어올려지는 것처럼 작동합니다.
  - `var`은 블록 레벨 스코프를 지원하지 않으므로 의도치 않게 변수가 덮어씌워지거나 누락될 수 있습니다.
  - 새로운 코드에서는 `var` 대신 `let`과 `const`를 사용하는 것이 권장됩니다.
- **`let`**
  - ES6에서 도입된 `let`은 블록 레벨 스코프를 갖습니다. 이는 변수가 선언된 블록 내에서만 접근할 수 있음을 의미합니다.
  - 호이스팅되지만 초기화되지 않은 상태로 존재하므로 참조 에러를 발생시킬 수 있습니다.
  - 변수의 값이 변경될 가능성이 있는 경우에 `let`을 사용하는 것이 적절합니다.
- **`const`**
  - ES6에서 도입된 `const`는 블록 레벨 스코프를 갖습니다. 상수 값을 정의할 때 사용되며, 선언과 동시에 초기화가 필요합니다.
  - `const`로 선언된 변수는 재할당이 불가능하지만, 객체나 배열의 경우 내용물은 변경이 가능합니다.
  - 값이 변하지 않는 상수 값을 정의할 때 사용합니다.
- **사용 컨벤션**
  - 기본적으로 `let`과 `const`를 사용하고, 값이 변하지 않는 경우에는 `const`를, 값이 변할 가능성이 있는 경우에는 `let`을 사용하는 것이 좋습니다.
  - `var`는 기존 코드와의 호환성을 위해 사용하는 경우를 제외하고는 지양하는 것이 바람직합니다.

<br>

## 자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?

> 스레드란 프로세스 내에서 독립적으로 실행되는 작업단위 입니다.
> 스레드는 프로그램의 실행 흐름을 처리하며, 각 스레드는 자체적으로 코드 실행, 스택, 레지스터 등을 갖고 있습니다.

- 스레드의 역할
  - 병렬처리: 여러 스레드를 사용하여 동시에 여러 작업을 처리할 수 있습니다.
  - 경량 프로세스: 스레드는 프로세스 내에서 실행되므로 메모리 사용이 적고, 생성과 전환이 빠릅니다.
- 스레드의 특징
  - 독립 실행: 각 스레드는 독립적으로 실행되지만, 같은 프로세스 내에서 자원(메모리 등)을 공유합니다.
  - 컨텍스트 전환: 스레드 간의 전환은 빠르지만, 컨텍스트 전환이 빈번할 경우 성능에 영향을 미칠 수 있습니다.

<br>

> 브라우저는 싱글 스레드로 자바스크립트를 실행하지만, 전체 브라우저의 아키텍처는 멀티 스레드를 사용합니다.

- 메인 스레드: 자바스크립트 코드와 DOM 렌더링을 처리합니다. 이 메인 스레드는 싱글 스레드로 동작합니다.
- 다른 스레드 - **렌더링 스레드**: 페이지의 렌더링, 레이아웃 계산 등을 담당합니다. - **네트워크 스레드**: 네트워크 요청과 응답을 처리합니다. - **웹 워커(Web Worker)**: 별도의 스레드에서 자바스크립트를 실행하여 메인 스레드의 부하를 줄입니다.
  <br>

## 자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?

> 다른 함수를 인자로 받거나, 함수를 반환하는 함수입니다.

- **장점**
  - 코드의 중복을 줄이고, 공통된 로직을 재사용할 수 있습니다.
  - 동작을 인자로 전달하여 함수를 유연하게 조정할 수 있습니다.
  - 함수형 프로그래밍 패러다임을 지원하여 순수 함수와 불변성을 장려합니다.

<br>

## 자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.

try...catch는 JavaScript에서 에러를 처리하기 위한 구문입니다. 이 구문의 기본적인 작동 방식은 다음과 같습니다.

> **`try` 블록**: 예외가 발생할 수 있는 코드를 작성합니다.<br> > **`catch` 블록**: 예외가 발생했을 때 실행되는 코드를 작성합니다.<br> > **`finally` 블록**: 예외 발생 여부와 관계없이 항상 실행되는 코드를 작성합니다(선택적).

catch 블록은 에러 객체를 매개변수로 받습니다. 이 객체는 발생한 에러에 대한 정보를 담고 있으며, 주로 name과 message 속성을 통해 에러의 종류와 설명을 제공합니다.

try...catch는 주로 다음과 같은 상황에서 사용됩니다.

1. 외부 리소스 접근: API 호출, 파일 읽기/쓰기 등 실패 가능성이 있는 작업
2. 사용자 입력 처리: 잘못된 형식의 데이터 입력에 대비
3. 타입 변환: 숫자로 변환할 수 없는 문자열 처리 등
4. 비동기 작업: Promise 기반 코드에서 오류 처리
5. 라이브러리/모듈 사용: 외부 코드에서 발생할 수 있는 예기치 않은 오류 처리

<br>

## 프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.

> 프러미스는 비동기 작업의 완료 또는 실패를 처리하는 객체입니다.<br>
> 성공 시 `resolve`, 실패 시 `reject`를 호출하여 비동기 작업의 결과를 처리할 수 있습니다.

> 콜백 지옥(callback hell)을 방지하고, 체이닝(chaining)을 통해 비동기 작업을 직관적으로 처리할 수 있습니다.<br> > `catch`를 사용하여 비동기 작업에서 발생한 에러를 처리할 수 있습니다.<br>
> 여러 비동기 작업을 동시에 실행하고, 모든 작업이 완료된 후 결과를 처리하는 기능을 제공합니다.

<br>

## 자바스크립트의 Strict Mode에 대해 설명해보세요.

> 자바스크립트의 엄격한 모드로, 코드의 오류를 더 엄격하게 검사하고,
> 일부 기능을 비활성화하여 보다 안전하고 예측 가능한 코드를 작성할 수 있도록 합니다.

- **특징**
  - **엄격한 문법**
    - 예를 들어, 변수의 선언 없이 사용된 변수는 오류를 발생시킵니다.
    - **`this`의 문제**: 함수 내에서 `this`가 `undefined`로 설정되며, 더 명확한 컨텍스트를 요구합니다.
    - 함수 선언은 스크립트나 함수의 최상위 레벨에서만 허용됩니다.
  - **금지된 구문**: 예약어 사용을 금지하는 등 특정 구문을 제한합니다.

<br>

## 렉시컬 환경과 렉시컬 스코프란 무엇인가요?

> 렉시컬 환경(Lexical Environment)은 자바스크립트에서 코드 실행 시 변수를 저장하고 관리하는 구조입니다.<br>
> 각 함수나 블록이 실행될 때 렉시컬 환경이 생성되며, 변수와 함수 선언을 포함한 환경 레코드와 외부 스코프에 대한 참조를 갖습니다.

> 렉시컬 스코프(Lexical Scope)는 자바스크립트에서 함수가 정의된 위치에 따라 변수 접근 범위가 결정되는 규칙을 의미합니다.<br>
> 함수가 어디에서 호출되든 상관없이, 함수가 정의된 위치에 따라 스코프가 고정되어, 해당 위치에서 참조 가능한 변수들만 접근할 수 있습니다.

1. 렉시컬 환경 (Lexical Environment)
   - 변수와 그 값을 저장하는 환경 레코드(Environment Record)입니다.
   - 외부 환경에 대한 참조를 포함합니다.
   - 코드의 중첩 구조를 반영하여 계층적으로 구성됩니다.
2. 렉시컬 스코프 (Lexical Scope)
   - 함수나 변수가 선언된 위치에 따라 접근 가능한 범위가 결정됩니다.
   - 내부 함수에서 외부 함수나 전역 스코프의 변수에 접근 가능합니다.
   - 코드 작성 시점에 결정되며, 런타임에 변경되지 않습니다.
     - 렉시컬 스코프는 정적 스코프의 한 형태입니다.
       - 정적 스코프: 코드가 작성된 시점에 스코프가 결정됨
       - 동적 스코프: 코드가 실행되는 시점에 스코프가 결정됨

<br>

## 0.1 + 0.2 === 0.3는 왜 false인가요?

> **`0.1`과 `0.2`가 이진수로 정확하게 표현될 수 없기 때문에 `0.1 + 0.2`가 `0.3`과 정확히 일치하지 않는 것입니다.**<br>
> 자바스크립트를 포함한 대부분의 프로그래밍 언어는 숫자를 IEEE 754 표준에 따라 부동 소수점으로 표현합니다.

### 부동 소수점이란 ?

> 부동 소수점(floating point)은 컴퓨터에서 실수를 표현하는 방법입니다.
> 숫자의 크기와 소수점을 동적으로 조정할 수 있어 매우 큰 숫자나 매우 작은 숫자를 표현할 수 있습니다.
> 부동 소수점 표현은 컴퓨터가 숫자를 처리하고 계산할 때 일반적으로 사용됩니다.

### 부동 소수점의 문제점

- **정확도 제한**: 유한한 비트 수로 소수를 표현하기 때문에 정확한 값으로 표현할 수 없는 경우가 많습니다.
- **근사치 오류**: 일부 연산 결과가 근사치로 표현되며, 이로 인해 예기치 않은 오류가 발생할 수 있습니다.
  <br><br>

이러한 문제를 해결하기 위해서 소수점을 정수로 변환하여 비교할 수 있습니다.

# React

## 리액트의 상태 끌어올리기는 어떤 단점이 있을까요?

> 상태 끌어올리기의 단점은 복잡도 증가, 불필요한 렌더링, 재사용성 감소입니다.

- 복잡도 증가
  - 상태를 부모 컴포넌트로 끌어올리면, 부모 컴포넌트가 더 많은 책임을 지게 됩니다.
    이는 부모 컴포넌트의 코드가 복잡해지고 관리하기 어려워질 수 있음을 의미합니다.
  - 여러 자식 컴포넌트가 상태를 공유할 때, 상태와 관련된 로직이 중앙에서 관리되어야 하기 때문에 코드의 가독성이 떨어질 수 있습니다.
- 불필요한 렌더링
  - 부모 컴포넌트의 상태가 변경되면, 그 부모와 모든 자식 컴포넌트가 다시 렌더링될 수 있습니다.
    이로 인해 성능 저하가 발생할 수 있으며, 불필요한 렌더링이 성능에 영향을 미칠 수 있습니다.
- 재사용성 감소
  - 상태를 중앙에서 관리하게 되면, 해당 상태와 관련된 로직이 특정 컴포넌트에 강하게 결합됩니다.
    이로 인해 컴포넌트의 재사용성이 떨어질 수 있으며, 다양한 상황에서 재사용하기 어려워질 수 있습니다.

<br>

## 가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?

### 가상 DOM(Virtual DOM)란?

> 실제 브라우저의 DOM(Document Object Model)을 추상화한 JavaScript 객체의 표현입니다.<br>
> 이는 메모리에 존재하는 가벼운 복사본으로, 실제 DOM의 구조를 모방합니다.

### 장점

- **성능 향상**: 가상 돔은 실제 DOM을 직접 조작하는 대신 메모리 상에서 가벼운 돔을 조작합니다. 이를 통해 DOM 업데이트의 성능을 개선할 수 있습니다.
- **효율적인 업데이트**: 가상 돔은 변경된 부분만을 비교하여 최소한의 실제 DOM 업데이트를 수행합니다. 이로 인해 전체 페이지의 렌더링 성능이 최적화됩니다.

### 단점

- **추가 메모리 사용**: 가상 돔을 유지하기 위해 추가 메모리가 필요합니다. 이는 메모리 사용량이 증가하는 원인이 됩니다.
- **추가 오버헤드**: 가상 돔과 실제 DOM을 비교하는 과정에서 약간의 성능 오버헤드가 발생할 수 있습니다. 이는 리액트의 diffing 알고리즘에 따른 것입니다.

<br>

## 리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.

> 리액트의 Diffing Algorithm은 Virtual DOM과 실제 DOM 간의 차이를 비교하여 효율적으로 업데이트를 수행합니다.

1. 서로 다른 타입의 엘리먼트는 새로 렌더링
   리액트는 엘리먼트의 타입이 다르면, 기존의 노드를 완전히 제거하고 새로운 노드를 만들어 렌더링합니다.<br>
   예를 들어, div를 span으로 변경하면 리액트는 기존 div를 삭제하고 새로운 span을 만들어서 화면에 보여줍니다.<br>
   이는 두 엘리먼트가 완전히 다르기 때문에 필요한 작업입니다.

2. 같은 타입의 엘리먼트는 속성만 비교
   만약 엘리먼트의 타입이 같다면, 리액트는 해당 엘리먼트의 속성만 비교합니다.<br>
   즉, 속성에 변경이 있으면 그 부분만 업데이트하고, 엘리먼트의 자식들은 그대로 유지합니다.<br>
   예를 들어, div className="old" Text /div 에서 className을 "new"로 바꾸면, 리액트는 className 속성만 수정하고 자식 엘리먼트인 "Text"는 그대로 두는 식입니다.

3. 리스트에서는 key를 통해 최적화
   리스트를 렌더링할 때는 각 항목에 고유한 key를 부여하는 것이 중요합니다.<br>
   이렇게 하면 리액트가 각 항목을 추적할 수 있어서, 항목의 순서가 바뀌거나 추가되거나 삭제될 때 더 효율적으로 처리할 수 있습니다.<br>
   예를 들어, 리스트에서 li 엘리먼트에 key 속성을 사용하면, 리액트는 항목의 위치만 조정하거나 새로운 항목을 추가하는 데에 더 빠르게 반응합니다.

이 알고리즘 덕분에 리액트는 전체 DOM을 다시 그리는 대신 필요한 부분만 업데이트할 수 있어서 성능을 최적화합니다.<br>
리액트의 Diffing Algorithm은 이런 방식으로 빠르고 효율적인 DOM 업데이트를 가능하게 해 줍니다.

<br>

## 리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?

> 리액트에서 상태를 업데이트할 때, 호출된 상태 업데이트 함수는 즉시 상태를 새값으로 변경하지 않습니다.<br>
> 대신, 업데이트 요청은 내부 큐에 저장되며, 이 큐는 비동기적으로 처리됩니다.<br>
> 즉, 상태의 실제 변경은 현재 렌더링 사이클이 끝나고, 다음 렌더링 사이클에서 이루어집니다.<br>
> 이로 인해 상태 업데이트 요청이 곧바로 반영되지 않고, 상태값이 새로운 값으로 업데이트되는 데 시간이 걸립니다.
>
> 그 이유는

1. 성능 최적화
   - 비동기 상태 업데이트를 통해 리액트는 여러 상태 변경 요청을 하나의 배치로 처리할 수 있습니다.
     즉, 상태 업데이트가 일어날 때마다 바로 렌더링을 하지 않고, 여러 업데이트를 한 번에 처리하여 렌더링 횟수를 줄입니다.
     이렇게 함으로써 렌더링 성능을 개선하고 불필요한 렌더링을 방지합니다.
2. 일관성 유지
   - 비동기 처리는 상태 업데이트의 일관성을 유지하는데 도움을 줍니다.
   - 상태가 동기적으로 처리되면, 연속적인 상태 변경이 서로 영향을미치거나 예상치 못한 결과를 초래할 수 있습니다.
   - 비동기적으로 처리하면 상태 변경 예측이 가능하고 일관되게 이루어지며, 예상되는 동작을 보장합니다.

따라서 비동기 상태 업데이트는 성능을 최적화하고 상태 변경의 일관성을 보장하기 위해 리액트의 설계에 포함된 것입니다.
<br>

## 리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?

> 리액트 컴포넌트 내부에서 모든 함수를 `useCallback`으로 감싸는 것이 좋냐고 묻는다면, 상황에 따라 다릅니다. 다음과 같은 점들을 고려해야 합니다:

1. **성능 최적화 필요성**
   - `useCallback`은 주로 함수가 자식 컴포넌트에 props로 전달되거나, 종속성 배열에 있는 값이 변경될 때마다 함수가 새로 생성되는 것을 방지하는 데 사용됩니다.
   - 만약 자식 컴포넌트가 `React.memo`를 사용하고 있거나, 함수가 자주 호출되는 경우라면 `useCallback`을 사용하는 것이 성능을 최적화하는 데 도움이 될 수 있습니다.
2. **불필요한 리렌더링 방지**
   - `useCallback`을 사용하면 함수가 매 렌더링마다 새로 생성되는 것을 방지할 수 있어서, 자식 컴포넌트의 불필요한 리렌더링을 줄일 수 있습니다.
   - 하지만, 모든 함수에 `useCallback`을 사용하면 오히려 코드가 복잡해지고, 성능 개선보다는 오버헤드가 발생할 수 있습니다.
3. **간단한 함수에는 필요 없음**
   - 단순한 핸들러 함수나, 렌더링 중에만 사용되는 간단한 함수에는 `useCallback`을 사용할 필요가 없습니다. 이런 함수들은 성능에 미치는 영향이 적고, `useCallback`으로 감싸는 것이 오히려 코드의 가독성을 떨어뜨릴 수 있습니다.
4. **코드 유지보수 고려**
   - 너무 많은 `useCallback` 사용은 코드 유지보수를 어렵게 할 수 있습니다. 어떤 함수에 `useCallback`을 사용할지 결정하는 기준을 세우는 것이 중요합니다.
   - 자주 호출되거나 렌더링 성능에 영향을 미치는 함수에만 `useCallback`을 사용하는 것이 좋습니다.

결론적으로, 모든 함수를 `useCallback`으로 감싸는 것보다는, 성능이 중요한 부분이나 자식 컴포넌트에 전달되는 함수에만 사용하는 것이 더 바람직합니다. 각 함수의 용도와 사용 빈도에 따라 적절히 적용하는 것이 좋습니다.
