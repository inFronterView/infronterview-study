# 목차

- JavaScript
  - [var, let, const 차이?](#var-let-const-차이)
  - [자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?](#자바스크립트는-싱글-스레드라고-합니다-스레드란-무엇인가요-브라우저도-싱글-스레드일까요)
  - [자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?](#자바스크립트에는-다양한-고차함수-형식의-메소드가-있습니다-고차함수의-장점은-무엇일까요)
  - [자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하나요?](#자바스크립트의-trycatch의-기본적인-작동방식-그리고-언제-어떤-경우에-사용해야-하나요)
  - [프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.](#프러미스를-사용하는-이유는-무엇인지-최대한-자세히-설명해보세요)
  - [자바스크립트의 Strict Mode에 대해 설명해보세요.](#자바스크립트의-strict-mode에-대해-설명해보세요)
  - [렉시컬 환경과 렉시컬 스코프란 무엇인가요?](#렉시컬-환경과-렉시컬-스코프란-무엇인가요)
  - [0.1 + 0.2 === 0.3는 왜 false인가요?](#010203는-왜false인가요)
- React
  - [리액트의 상태 끌어올리기는 어떤 단점이 있을까요?](#리액트의-상태-끌어올리기는-어떤-단점이-있을까요)
  - [가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?](#가상돔이라는-존재는-무엇이며-장점과-단점은-어떤-것들이-있을까요)
  - [리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.](#리액트의-diffing-algorithm의-내부-로직에-대해서-최대한-자세히-설명해보세요)
  - [리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?](#리액트의-상태-업데이트는-비동기로-실행됩니다-이-말은-무슨-뜻이며-왜-그럴까요)
  - [리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?](#리액트-컴포넌트-내부에서-모든-함수를usecallback으로-감싸는-것이-좋을까요)

<br>

# JavaScript

## var, let, const 차이?

> `var`는 함수 스코프를 가지며 호이스팅이 되고, 재선언과 재할당이 가능합니다.
> `let`은 블록 스코프를 가지며, 호이스팅되지만 선언 전 접근이 불가하며 재할당만 가능합니다.
> `const`는 블록 스코프와 호이스팅을 가지며, 재할당이 불가능하지만 객체나 배열의 내부 변경은 허용됩니다.
>
> `var`는 함수 스코프를 가지고 있습니다. 이는 변수가 선언된 함수 내에서 어디서든 접근이 가능하다는 뜻입니다. 다만, 블록 내에서 선언된 `var` 변수도 블록 밖에서 접근할 수 있기 때문에, 의도치 않은 동작이 발생할 수 있습니다. 또한 `var`는 호이스팅이 되어, 선언이 코드의 최상단으로 끌어올려지지만, 초기화는 끌어올려지지 않습니다. 그래서 변수를 선언하기 전에 참조하면 `undefined`가 반환됩니다. 그리고 `var`는 동일한 스코프 내에서 재선언과 재할당이 가능합니다.

`let`은 블록 스코프를 가지고 있습니다. 즉, 변수가 선언된 블록 내에서만 유효하며, 블록 밖에서는 접근할 수 없습니다. 이는 var에 비해 더 안전하게 변수를 관리할 수 있게 해줍니다. `let`도 호이스팅되지만, `Temporal Dead Zone(TDZ)`이라는 개념이 적용되어 선언 전에 변수를 참조하면 에러가 발생합니다. 또한 `let`으로 선언된 변수는 동일한 스코프 내에서 재선언할 수 없지만, 재할당은 가능합니다.

`const`는 상수를 선언하는 데 사용되며, 한 번 값이 할당되면 재할당이 불가능합니다. `const`도 블록 스코프를 가지며, `let`과 마찬가지로 호이스팅되지만 `Temporal Dead Zone` 때문에 선언 전에 접근할 수 없습니다. 그러나 `const`로 선언된 객체나 배열은 그 내부의 속성이나 요소를 변경할 수 있습니다. 변경할 수 없는 것은 변수 자체에 할당된 참조이며, 객체나 배열의 내용은 변할 수 있다는 점에서 `const`는 변경 가능한 상수라고도 할 수 있습니다.

`var`는 주로 과거에 사용되었지만, 스코프 관리의 불편함 때문에 최근에는 잘 쓰이지 않습니다. 대신 `let`과 `const`가 사용되며, 재할당이 필요하면 `let`, 한 번 정해지면 바뀌지 않는 값을 선언할 때는 `const`를 사용하는 것이 일반적입니다.

<br>

## 자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?

> 스레드는 **하나의 프로세스 내에서 독립적인 실행 흐름**을 의미하며, 자바스크립트는 기본적으로 싱글 스레드로 동작해 한 번에 하나의 작업만 처리할 수 있습니다.
> 비동기 작업은 이벤트 루프를 통해 관리되며, 브라우저는 웹 워커를 이용해 백그라운드 작업을 멀티스레드로 처리할 수 있습니다.

**스레드**는 하나의 프로세스 내에서 실행되는 독립적인 실행 흐름을 말하는데, 여기서 프로세스란 **_실행중에 있는 프로그램(Program_**), 즉, 하나의 작업(Task)입니다. 스레드는 프로세스의 자원을 공유하면서 동시에 여러 작업을 수행할 수 있게 해줍니다.
자바스크립트는 기본적으로 싱글 스레드로 동작합니다. 이는 한 번에 하나의 작업만을 처리할 수 있다는 의미입니다. 자바스크립트 엔진(예: V8)은 하나의 호출 스택인 **_콜 스택_**을 가지고 있어, 코드를 순차적으로 실행합니다.

자바스크립트가 싱글 스레드임에도 불구하고 비동기 작업을 처리할 수 있는 이유는 **_이벤트 루프(Event Loop)_** 때문입니다. 이벤트 루프는 비동기 작업을 관리하고, 작업이 완료되면 콜백 함수를 호출 스택에 추가합니다.

**브라우저도 기본적으로 싱글 스레드**로 작동합니다. 자바스크립트 코드 실행과 UI 렌더링 등이 동일한 스레드에서 처리됩니다. 하지만, 브라우저는 웹 워커(Web Workers)나 서비스 워커(Service Workers)와 같은 기능을 통해 백그라운드 작업을 멀티스레드로 처리할 수 있도록 지원합니다. 이로 인해, 메인 스레드에서 부하가 걸리지 않도록 백그라운드에서 작업을 처리할 수 있습니다.

**왜 자바스크립트가 싱글스레드로 만들어졌는지?**
자바스크립트는 **웹페이지의 보조적인 기능을 수행하기 위해 만들어진 경량 프로그래밍 언어**입니다. 만들어진 당시에는 복잡한 기능을 포함하지 않아 단일 스레드로 만들어졌습니다.

## 자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?

> 고차함수는 다른 함수를 인수로 받거나 반환하는 함수로, map, filter, reduce 등이 대표적입니다. 고차함수는 코드의 가독성을 높이고, 재사용성을 증가시키며, 함수형 프로그래밍을 지원해 오류를 줄이고 유지보수를 용이하게 합니다.
>
> 고차함수는 **다른 함수를 인수로 받거나 함수를 반환하는 함수**입니다.

예를 들어, `map`, `filter`, `reduce` 같은 메소드들이 대표적인 고차함수입니다. 고차함수의 가장 큰 장점 중 하나는 **코드의 가독성**을 높여준다는 점입니다. 복잡한 로직을 간결하게 표현할 수 있어, 반복문을 사용하는 것보다 코드가 훨씬 직관적이고 읽기 쉬워집니다.

또한, 고차함수를 사용하면 **코드의 재사용성**이 높아집니다. 예를 들어, 특정 조건을 만족하는 요소를 필터링하는 로직을 `filter` 메소드에 콜백 함수로 전달하면, 이를 다른 배열에서도 쉽게 재사용할 수 있습니다. 이는 유지보수에도 큰 도움이 됩니다.

고차함수는 **함수형 프로그래밍을 지원**하는 중요한 도구이기도 합니다. **불변성**과 **순수 함수의 개념**을 유지하면서 코드를 작성할 수 있게 해줘, 오류를 줄이고 유지보수를 용이하게 합니다.

<br>

## 자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하나요?

`try..catch` 문은 코드에서 발생할 수 있는 **오류를 처리하기 위해 사용**됩니다.

**기본적인 작동방식?**
기본적으로 `try` 블록 안에 **실행할 코드를 작성**하고, 오류가 발생하면 `catch` 블록에서 **해당 오류를 처리**합니다. 이러한 구조는 오류가 발생했을 때 코드의 흐름을 제어하고, 사용자에게 유의미한 메시지를 제공하거나 대체 동작을 수행할 수 있도록 합니다.

**어떤 경우에 사용?**
`try..catch` 문은 특히 **외부 입력을 처리하거나, 비동기 작업, 파일 입출력, 네트워크 요청 등 오류가 발생할 가능성이 있는 상황에서 사용**됩니다. 예를 들어, 서버에 데이터를 요청하는 동안 네트워크 오류가 발생할 수 있는데, 이때 `try..catch`를 사용하면 오류를 감지하고 적절한 대처를 할 수 있습니다. 이를 통해 프로그램이 예상치 못한 오류로 인해 중단되지 않고 안정적으로 동작하도록 보장할 수 있습니다.

<br>

## 프러미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.

> 프라미스는 비동기 작업을 명확하게 관리하고 에러 처리를 간편하게 해줍니다. 체이닝과 **async/await**를 사용하면 코드 가독성을 높이고, 여러 비동기 작업을 동시에 처리할 수 있습니다. 이러한 특성 덕분에 **비동기 코드의 유지보수와 디버깅이 쉬워집니다.**
>
> 프라미스를 사용하는 이유는 비동기 작업을 효율적으로 관리하기 위해서입니다. 프라미스는 비동기 작업의 성공이나 실패를 명확히 처리할 수 있게 해주며, `.then()`과 `.catch()` 메소드를 통해 결과를 간결하게 다룰 수 있습니다.

프라미스를 사용하면 여러 비동기 작업을 순차적으로 처리할 수 있는 **체이닝**이 가능하고, 코드가 **콜백 지옥**에 빠지지 않게 도와줍니다. 에러 처리도 간편해져서, 오류를 중앙에서 관리하고 디버깅을 쉽게 할 수 있습니다. 게다가, `Promise.all()`을 통해 여러 비동기 작업이 모두 완료된 후에 후속 작업을 처리할 수 있어 동시 작업 관리도 용이합니다. 마지막으로, `async/await`와 함께 사용하면 비동기 코드를 동기식 코드처럼 작성할 수 있어 코드의 가독성이 크게 향상됩니다.

<br>

## 자바스크립트의 Strict Mode에 대해 설명해보세요.

자바스크립트의 Strict Mode는 코드 실행 시 더 **엄격한 규칙을 적용하여 잠재적인 오류를 줄이고, 안전하고 최적화된 코드를 작성하도록 도와주는 기능**입니다.
`ECMAScript 5(ES5)`에서 도입되었으며, `"use strict";`라는 지시어를 통해 활성화할 수 있습니다. 이 지시어는 파일 전체 또는 특정 함수 내부에서 사용할 수 있으며, 특정한 문법적 실수를 방지합니다.

<br>

## 렉시컬 환경과 렉시컬 스코프란 무엇인가요?

> **렉시컬 스코프**는 변수가 정의된 위치에 따라 범위를 결정하고, **렉시컬 환경**은 그 범위에서 변수와 함수의 상태를 관리하는 구조입니다.

**렉시컬 스코프**는 변수가 선언된 위치에 따라 그 변수의 범위가 결정되는 방식을 말합니다. 즉, 함수가 정의된 위치에 따라 변수의 접근 가능 범위가 결정됩니다. 자바스크립트는 렉시컬 스코프를 사용하여 함수가 어디서 선언되었는지에 따라 변수에 접근할 수 있습니다.

**렉시컬 환경**은 변수와 함수의 실행 컨텍스트를 포함하는 객체입니다. 함수가 호출될 때마다 새로운 렉시컬 환경이 생성되며, 이 환경은 해당 함수에서 선언된 변수와 함수에 대한 정보를 담고 있습니다.
렉시컬 **환경은 변수와 함수의 실제 값과 정의를 저장하는 환경 레코드**와 **상위 스코프에 대한 참조를 유지해 상위 변수에 접근할 수 있도록 하는 외부 렉시컬 환경에 대한 참조**로 이루어져있습니다.

<br>

## 0.1 + 0.2 === 0.3는 왜 false인가요?

> 자바스크립트가 부동 소수점을 이진 형식으로 저장하여 정확한 10진수 표현이 어려워서
>
> `0.1 + 0.2 === 0.3`이 `false`인 이유는 자바스크립트에서 숫자를 이진 부동 소수점으로 표현하기 때문입니다. 부동 소수점 숫자는 컴퓨터 내부에서 이진 형태로 저장되며, 10진수의 정확한 표현이 어렵기 때문에 오차가 발생할 수 있습니다.

구체적으로,` 0.1`과 `0.2`를 이진 부동 소수점으로 변환하면 무한 소수로 표현됩니다. 이 때문에 `0.1 + 0.2`의 결과는 `0.3`에 아주 근접하지만, 정확히 `0.3`과 일치하지 않게 됩니다. 이 오차 때문에 비교 연산을 수행하면 `false`가 됩니다.

**해결법**
이 문제를 해결하기 위해 자바스크립트에서는 보통 소수점을 비교할 때 작은 오차 범위를 허용하여 비교합니다. 예를 들어, `Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON`을 사용하여 두 값이 충분히 가까운지 확인할 수 있습니다. `Number.EPSILON`은 부동 소수점 숫자에서 비교 시 허용할 수 있는 가장 작은 오차 범위를 나타냅니다.

<br>

<br>
<br>

# React

## 리액트의 상태 끌어올리기는 어떤 단점이 있을까요?

리액트에서 상태를 끌어올리는 것은 여러 컴포넌트 간에 상태를 공유할 때 유용하지만, 몇 가지 단점이 있습니다.

첫째, 상태를 상위 컴포넌트로 끌어올리면, 그 상위 컴포넌트가 너무 많은 상태와 책임을 가지게 되어 **코드의 복잡성이 증가**할 수 있습니다.

둘째, 상태가 변경될 때 하위 컴포넌트들이 **불필요하게 리렌더링**될 수 있어 성능에 영향을 미칠 수 있습니다.

셋째, 많은 상태와 프로퍼티를 상위 컴포넌트에서 관리하게 되면, 하위 컴포넌트에 전달해야 할 프로퍼티가 증가하고, `props drilling` 이 일어날 수 있습니다.

이러한 문제를 해결하기 위해 **상태 관리 라이브러리**나 React의 `Context API`를 사용할 수 있습니다.

<br>

## 가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?

가상 DOM은 **실제 DOM의 가벼운 복사본**으로, UI의 변화를 추적하고 업데이트를 최적화하는 데 도움을 줍니다.

**장점**
상태가 변경되었을 때 실제 DOM을 직접 수정하는 대신, 가상 DOM에서 변경된 부분만을 계산하고, 실제 DOM에는 **최소한의 변경만을 적용**할 수 있습니다. 이러한 방식은 성능을 향상시키고 렌더링 속도를 빠르게 하며, 리소스를 절약하는데 도움을 줍니다.

**단점**
가상 DOM은 실제 DOM의 복사본을 유지하므로 메모리 사용량이 증가할 수 있습니다. 또한, 가상 DOM을 구현하고 관리하는 데 필요한 로직이 추가되어 **코드의 복잡성이 증가**할 수 있으며, 잘못된 사용이나 과도한 상태 업데이트로 인해 **성능 저하가 발생**할 수 있습니다.

<br>

## 리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.

리액트의 `Diffing Algorithm`은 가상 DOM을 사용해 UI 업데이트를 효율적으로 처리하는 기술입니다. 이 알고리즘은 같은 계층의 노드끼리만 비교하고, 노드의 타입이 다르면 전체 노드를 교체합니다. 동일한 타입의 노드는 자식 노드들을 재귀적으로 비교하며, key 속성을 활용해 요소의 이동이나 삭제를 최적화합니다. 리액트는 상태 업데이트를 일괄 처리하고, 작업의 우선순위를 관리하여 성능을 최적화합니다. 이로 인해, 변경된 부분만을 실제 DOM에 적용하여 UI의 성능과 응답성을 개선할 수 있습니다.

**더 자세하게**

**다른 타입의 두 요소는 서로 다른 트리로 간주된다.**
두 요소가 다른 타입이면, 그 하위 트리를 모두 삭제하고 새로 생성합니다. 예를 들어, `<div>`에서 `<span>`으로 변환된다면, `<div>`의 모든 하위 요소를 제거하고 `<span>`과 그 하위 요소를 새로 렌더링합니다.

**같은 타입의 두 요소는 속성만 비교하여 변경사항을 업데이트한다.**
동일한 타입의 요소는 속성만 비교하고, 변경된 속성만을 업데이트합니다. 예를 들어, `<div>`에서 `className`만 변경되었다면, 리액트는 오직 `className` 속성만 업데이트하고 나머지 구조는 그대로 둡니다.

**리스트의 경우, 키(Key)를 사용해 요소의 이동을 추적한다.**
리스트의 요소들은 `key` 속성을 기반으로 비교됩니다. `key`는 리스트에서 각 요소를 고유하게 식별하는 값입니다. 이 `key`가 동일하다면 리액트는 그 요소가 동일한 것으로 간주하고 위치만 변경하거나 속성만 업데이트합니다. `key`가 다르면 리액트는 요소를 새로 추가하거나 제거합니다.

<br>

## 리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?

> 비동기 처리를 통해 **여러 상태 업데이트를 배치로 묶어 한 번에 처리함으로써 불필요한 렌더링을 줄이고, UI의 응답성을 유지**합니다. 이 방식은 동기적 상태 업데이트로 인한 성능 저하를 방지하고, 전체 애플리케이션의 효율성을 높입니다.

리액트에서 상태 업데이트가 비동기로 실행된다는 말은, `setState` 함수 호출 후 상태가 즉시 업데이트되지 않고, 나중에 업데이트가 처리된다는 것을 의미합니다. 리액트가 성능을 최적화하고, 더 일관된 UI를 제공하기 위해서입니다.

`setState` 함수를 호출하면, 리액트는 상태 업데이트 요청을 큐(queue)에 넣지만, 즉시 상태를 변경하지는 않습니다. 대신, 리액트는 여러 상태 업데이트 요청을 하나로 묶어, 한 번의 재렌더링으로 처리합니다.

상태가 변경되면, 리액트는 해당 컴포넌트를 다시 렌더링해야 한다는 사실을 인식합니다. 그러나 이 렌더링은 자바스크립트의 이벤트 루프 내에서 스케줄링되며, 리액트는 성능을 고려해 최적의 시점에 렌더링을 수행합니다.

여러 개의 `setState` 호출이 발생하면, 리액트는 이를 병합(merge)하여 한 번의 렌더링으로 처리합니다. 즉, 컴포넌트는 상태 업데이트가 완료된 후에 한 번만 렌더링됩니다.

<br>

## 리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?

useCallback은 함수의 재생성을 방지하여 성능을 최적화하지만, 모든 함수에 적용하면 **메모리 사용량이 증가**하고 **코드 복잡성**이 높아질 수 있습니다. 특히, 자식 컴포넌트에 함수를 `props`로 전달할 때 유용하지만, 자주 변경되지 않는 함수나 최적화되지 않은 자식 컴포넌트에서는 큰 성능 이점을 얻기 어렵습니다.

**메모리 사용량 증가**
`useCallback`은 함수를 메모리에서 유지하여, 종속성 배열의 값이 변경될 때만 새로운 함수를 생성합니다. 하지만, 모든 함수를 `useCallback`으로 감싸면, 각 함수에 대해 메모리 공간이 할당되어 메모리 사용량이 불필요하게 늘어날 수 있습니다.

**코드 복잡성이 증가**
각 함수에 대해 종속성 배열을 정의해야 하므로 코드가 복잡해집니다.

**성능 이점이 제한적**
자식 컴포넌트에 함수를 `props`로 전달할 때, 자식 컴포넌트가 `React.memo` 같은 최적화 기법을 사용할 때 유용합니다. `useCallback`을 통해 함수가 재생성되지 않도록 보장하면, 자식 컴포넌트가 불필요하게 리렌더링되는 것을 방지할 수 있습니다. 그러나 자식 컴포넌트가 최적화되지 않거나, 함수가 자주 변경되지 않는 경우에는 `useCallback`의 효과가 크지 않을 수 있습니다.
