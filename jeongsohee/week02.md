# 목차

- JavaScript
  - [var, let, const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.](#링크)
  - [자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?](#링크)
  - [자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?](#링크)
  - [자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.](#링크)
  - [프로미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.](#링크)
  - [자바스크립트의 Strict Mode에 대해 설명해보세요.](#링크)
  - [렉시컬 환경과 렉시컬 스코프란 무엇인가요?](#링크)
  - [0.1 + 0.2 === 0.3는 왜 false인가요?](#링크)
- React
  - [리액트의 상태 끌어올리기는 어떤 단점이 있을까요?](#링크)
  - [가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?](#링크)
  - [리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.](#링크)
  - [리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?](링크)
  - [리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?](#링크)

# JavaScript

## var, let, const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.

var는 함수 스코프와 전역 스코프를 가집니다. 호이스팅이 되어 선언이 스코프의 최상단으로 끌어올려집니다. 재선언과 재할당이 가능해집니다. 그리고 블록 스코프를 무시합니다. let과 const는 둘다 블록 스코프를 가집니다. 호이스팅이 되지만 TDZ(Temporal Dead Zone)로 인해 선언 전 접근 시 에러가 발생합니다. 재선언은 불가능하지만, 재할당은 가능합니다. 하지만 const는 선언과 동시에 초기화해야 합니다. 재선언과 재할당이 모두 불가능합니다. 사용 컨벤션으로는 var는 예기치 않은 스코프 문제를 일으킬 수 있어서 가급적 사용하지 않습니다. const를 기본으로 사용하고 let은 변수의 값이 변경될 필요가 있을 때만 사용합니다.상수나 변경되지 않는 참조에는 const를 사용합니다.

<br>

## 자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?

스레드는 프로세스 내에서 운영체제로부터 할당받는 자원을 실행하는 단위입니다. 여기서 프로세스는 운영체제로부터 자원을 할당받은 작업의 단위입니다. 브라우저는 멀티 스레드입니다. 브라우저 마다 구조는 다르지만 대표적으로 크롬을 예로 들어 설명드리면 탭마나 하나의 프로세스로 이루어져 있는데 탭 하나에서 오류가 난다면 다른 탭에서 브라우저가 종료되는 것을 막기위해 멀티 프로세스로 구성되어있고 크게 브라우저 프로세스와 렌더러 프로세스로 이루어져 있는데 브라우저 프로세스에는 메인 UI 스레드와 I/O 스레드를 유지하면서 메인 UI 스레드는 탭을 관리하고, I/O 스레드를 이용하여 렌더러 프로세스와 통신하며 렌더러 프로세스가 UI를 그리도록 합니다. 렌더러 프로세는 메인 스레드와 렌더 스레드로 유지되어 있는데 메인 스레드는 렌더 스레드와 브라우저 프로세스와의 통신을 위한 렌더프로세스 객체가 존재합니다. 렌더 스레드는 웹 페이지를 생성합니다.

<br>

## 자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?

고차 함수를 사용하면 일반화된 로직을 추상화하고, 다양한 상황에서 재사용할 수 있습니다. 함수를 인자로 받아 처리하므로, 특정 동작을 필요에 따라 쉽게 변경하거나 확장할 수 있습니다. 또한 고차 함수를 사용하면 중복 코드를 줄이고, 함수의 동작을 명확하게 할 수 있습니다. 필요한 부분을 함수로 추출하여, 더 간결하고 읽기 쉬운 코드를 작성할 수 있습니다.

<br>

## 자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.

try…catch는 에러핸들링할 때 일반적으로 사용합니다. 성공하길 바라는 코드가 실패하면 catch로 제어권을 넘겨야할 때 사용합니다.
try…catch문은 하나 이상의 명령문을 포함하는 try 블록 그리고 try에서 예외가 발생할 경우 그 예외를 처리할 명령문을 담은 하나의 catch 블록으로 구성합니다. try 블록에서 발생할 수 있는 모든 예외는 catch 블록에서 처리할 수 있습니다. catch 블록은 throw 명령문이 던진 예외의 값을 담은 식별자를 지정합니다. finally 블록은 try 블록 안에서 예외가 발생했는지 여부에 관계 없이, catch 블록이 따로 존재하지 않더라도 항상 실행됩니다.

<br>

## 프로미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.

복잡한 비동기 작업을 중첩된 콜백으로 처리할 때 발생하는 ‘콜백 지옥’을 피할 수 있고 .then(), .catch(), .finally() 메서드를 통해 작업의 결과를 체계적으로 처리할 수 있습니다. promise.all(), promise.race() 등의 메서드를 통해 여러 비동기 작업을 쉽게 병렬로 처리할 수 있습니다.

<br>

## 자바스크립트의 Strict Mode에 대해 설명해보세요.

코드의 잠재적 문제를 조기에 발견하고 더 안전하고 최적화된 코드를 작성하는데 도움을 줍니다. use strict 문을 스크립트나 함수 시작 부분에 추가하여 활성화하는데 일반적으로 무시될 수 있는 오류들을 예외로 변환합니다. 그리고 암묵적 전역 변수 생성을 금지하고 변수 함수 매개변수의 삭제를 금지합니다. 그리고 전역 컨텍스트에서 함수를 호출 할 때 this가 undefined로 바인딩되고 함수 매개변수의 이름이 중복되는것을 금지합니다.

<br>

## 렉시컬 환경과 렉시컬 스코프란 무엇인가요?

렉시컬 환경은 자바스크립트 엔진이 코드를 실행할 때, 함수나 블록이 실행되는 동안 변수를 저장하고 관리하는 구조입니다. 쉽게 말해, 자바스크립트가 실행될 때 변수와 함수 선언을 추적하는 ‘저장 공간’을 의미합니다. 각 함수나 블록은 자신만의 렉시컬 환경을 가지며, 해당 범위 내에서 정의된 변수나 함수에 접근할 수 있습니다.렉시컬 스코프는 자바스크립트에서 함수가 정의된 위치에 따라 변수를 어디서 접근할 수 있는지를 결정하는 규칙을 의미합니다. 함수가 호출될 때가 아니라, 함수가 정의된 위치에 따라 그 함수가 접근할 수 있는 변수들이 결정됩니다. 즉, 함수가 선언된 코드의 물리적 위치에 따라 변수의 유효 범위가 정해집니다.

<br>

## 0.1 + 0.2 === 0.3는 왜 false인가요?

컴퓨터에서 부동소수점을 사용해 숫자를 표현할 때는 근본적인 한계가 있습니다. 10진수 소수를 2진수로 변환하는 과정에서 일부 숫자들이 무한소수가 되는데, 컴퓨터는 이를 유한한 메모리에 저장해야 합니다. 이 과정에서 미세한 값들이 초과되거나 손실되어 결과적으로 계산 오류가 발생하게 됩니다. 0.1과 0.2가 2진수로 정확하게 표현되지 않는 이유가 이때문입니다. 자바스크립트의 부동소수점 연산에서 발생하는 작은 오차로 인해 0.1 + 0.2의 결과는 0.30000000000000004가 됩니다. 이러한 문제를 해결하기 위해서는 소수점을 반올림하여 비교하거나, 허용 가능한 오차 범위를 설정하는 등의 방법을 사용할 수 있습니다.

<br>

# React

## 리액트의 상태 끌어올리기는 어떤 단점이 있을까요?

상태를 끌어올리면 모든 상태가 부모 컴포넌트에 집중되기 때문에, 부모 컴포넌트가 지나치게 복잡해질 수 있습니다. 여러 개의 상태를 끌어올리다 보면 부모 컴포넌트가 많은 상태와 상태 업데이트 로직을 처리하게 되어, 코드가 장황해지고 가독성이 떨어질 수 있습니다. 또한 부모 컴포넌트의 상태가 변경될 때마다 자식 컴포넌트도 다시 렌더링됩니다. 이는 자식 컴포넌트가 변경된 상태와 관련이 없더라도 렌더링되게 만들어, 성능에 부정적인 영향을 줄 수 있습니다. 이러한 단점을 극복하기 위해서는 전역 상태 관리 라이브러리, React Context API 등의 도구를 적절히 사용하여 상태 관리의 복잡성을 줄일 필요가 있습니다.

<br>

## 가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?

가상 DOM을 통해 실제 DOM을 직접 조작하는 횟수를 줄일 수 있습니다. 일반적으로 DOM 조작은 성능에 큰 영향을 미치며, 변경 사항이 있을 때마다 실제 DOM을 다시 그리면 성능 저하가 발생할 수 있습니다. 가상 DOM은 변경된 부분만 찾아내어 그 부분만 업데이트하기 때문에, 전체 DOM을 다시 그리는 작업을 피할 수 있어 성능이 향상됩니다. 가상 DOM을 사용하는 것 자체에도 비용이 발생합니다. 애플리케이션이 처음 렌더링될 때, 실제 DOM과 가상 DOM을 모두 만들어야 하기 때문에 초기 렌더링 시간이 다소 길어질 수 있습니다. 특히 애플리케이션의 컴포넌트가 많고 복잡할수록 초기 렌더링 성능에 영향을 미칠 수 있습니다.

<br>

## 리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.

React는 상태나 props가 변경되면, 변경된 상태를 기반으로 새로운 가상 DOM 트리를 생성합니다. 이 새로운 트리와 기존의 가상 DOM 트리를 비교하여 두 트리 간의 차이점을 찾아내고, 그 차이점을 실제 DOM에 반영하는 과정을 거칩니다. 여기에 사용되는 알고리즘이 Diffing 알고리즘인데 같은 종류의 노드만 비교하고, key 속성을 사용해 리스트를 최적화하며, 효율적인 트리 비교를 통해 성능을 향상시킵니다. 이를 통해 React는 대규모 애플리케이션에서도 빠르고 부드러운 사용자 경험을 제공합니다.

<br>

## 리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?

리액트의 setState가 비동기로 작동하는 이유는 일정 시간 동안 변화하는 상태를 모아 한번의 렌더링으로 처리하기 위해서입니다. 이 과정이 batch인데 웹 페이지에서의 불필요한 렌더링 횟수를 줄여 좀 더 빠른 속도로 동작하게 만들기 위해서입니다.

<br>

## 리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?

항상 새로 생성되는 값이 prop으로 전달되면 메모이제이션이 깨져서 리렌더링이 발생합니다. 이를 방지하려면 useMemo나 useCallback을 사용해 참조가 변경되지 않는 값을 prop으로 전달해야 합니다. 또한 useCallback을 사용해도 큰 성능 저하는 없지만, 불필요한 memoization은 코드 가독성을 떨어뜨릴 수 있습니다.
