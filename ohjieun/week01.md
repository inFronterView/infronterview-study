# 목차

- JavaScript
  - [EcmaScript와 JavaScript의 차이점은 무엇인가요?](#ecmascript와-javascript의-차이점은-무엇인가요)
  - [자바스크립트의 자료형(타입)에는 어떤 것들이 있나요?](#자바스크립트의-자료형타입에는-어떤-것들이-있나요)
  - [Document Object Model이란 무엇인가요?](#document-object-model이란-무엇인가요)
  - [이벤트 위임이란 무엇인가요? 이벤트 캡쳐링과 이벤트 버블링의 차이점은 무엇인가요?](#이벤트-위임이란-무엇인가요-이벤트-캡쳐링과-이벤트-버블링의-차이점은-무엇인가요)
  - [event.target과 event.currentTarget의 차이점에 대해 설명해보세요.](#eventtarget과eventcurrenttarget의-차이점에-대해-설명해보세요)
  - [Call by value와 Call by reference의 차이점은 무엇인가요?](#call-by-value와-call-by-reference의-차이점은-무엇인가요)
- React
  - [브라우저에 URL을 입력한 순간부터 화면에 웹 페이지가 나타나기까지의 모든 과정을 아는대로 최대한 자세히 설명해보세요.](#브라우저에-url을-입력한-순간부터-화면에-웹-페이지가-나타나기까지의-모든-과정을-아는대로-최대한-자세히-설명해보세요)
  - [package.json, package-lock.json, node_modules는 무엇인가요?](#packagejsonpackage-lockjsonnode_modules는-무엇인가요)
  - [Client Side Rendering이란 무엇인가요?](#client-side-rendering이란-무엇인가요)
  - [Single Page Application이란 무엇인가요?](#single-page-application이란-무엇인가요)
  - [상태 변화에 대해 React는 어떻게 반응할까요?](#상태-변화에-대해-react는-어떻게-반응할까요)
  - [리액트의 Strict Mode는 어떤 역할을 하는 것인지 최대한 자세히 설명해보세요.](#리액트의-strict-mode는-어떤-역할을-하는-것인지-최대한-자세히-설명해보세요)

<br>

# JavaScript

## EcmaScript와 JavaScript의 차이점은 무엇인가요?

EcmaScript는 프로그래밍 언어의 표준화된 사양입니다. 그리고 JavaScript는 이 EcmaScript 사양을 실제로 구현한 프로그래밍 언어입니다.

EcmaScript는 언어의 핵심 기능을 정의합니다. ECMA International이라는 단체에서 관리하는 ECMA-262라는 기술 규격에 정의되어 있습니다.

브라우저의 JavaScript는 이런 EcmaScript의 기능을 포함하면서도, 추가로 웹 브라우저에서 사용되는 DOM(Document Object Model)이나 BOM(Browser Object Model) 같은 API들을 포함하고 있습니다.

정리하자면, EcmaScript는 언어의 규격이고, JavaScript는 그 규격을 따르는 실제 프로그래밍 언어입니다.  
JavaScript는 EcmaScript의 모든 기능을 포함하면서도, 추가적인 기능을 제공한다는 점이 주요한 차이점입니다.

### 📝 EcmaScript가 생긴 이유
EcmaScript가 생긴 이유는 웹 브라우저 간의 **JavaScript 표준화를 통해 호환성을 확보**하고, **일관된 동작을 보장하기 위해서**입니다.

JavaScript는 1995년에 Netscape의 브렌던 아이크(Brendan Eich)에 의해 10일 만에 개발된 스크립트 언어로, 웹 페이지에 동적 요소를 추가하기 위해 만들어졌습니다.

JavaScript는 빠르게 인기를 얻었지만, 다양한 브라우저에서 서로 다른 방식으로 구현되면서 호환성 문제가 발생했습니다. 각 브라우저가 JavaScript를 다르게 해석하거나 추가적인 기능을 독자적으로 구현하면서 개발자들은 여러 브라우저에서 동일하게 작동하는 코드를 작성하기가 어려워졌습니다.

이 문제를 해결하기 위해 ECMA(유럽 컴퓨터 제조 협회)에서 JavaScript의 표준 사양을 정의하게 되었습니다. 그 결과 나온 표준 사양이 바로 ECMAScript입니다. ECMA-262라는 명세서에 표준이 정의되었고, 이를 통해 JavaScript가 어느 브라우저에서나 동일하게 동작할 수 있도록 규격이 정해졌습니다.

### 📝 EcmaScript에 새로운 기능이 추가되는 과정
[TC39 프로세스](https://tc39.es/process-document/)는 ECMAScript를 발전시키고 명세를 작성하는 과정입니다.
이 과정은 여러 단계로 구성되어 있으며, 아이디어에서 시작하여 완전히 명세화된 기능으로 발전시키는 가이드라인을 제공합니다.

주요 단계는 다음과 같습니다.

| 단계                 | 설명                                                                  |
|--------------------|---------------------------------------------------------------------|
| 단계 0 (Strawperson) | 새로운 제안 단계입니다. 아이디어 탐색 단계로, 문제 공간을 정의합니다.                            |
| 단계 1               | 제안이 고려 중인 단계입니다. 문제와 해결책의 일반적인 형태를 설명합니다.                           |
| 단계 2               | 위원회가 선호하는 해결책을 선택한 단계입니다. 설계는 초안 상태이며 변경될 수 있습니다.                   |
| 단계 2.7             | 제안이 원칙적으로 승인되고 검증 중인 단계입니다. 해결책이 완성되었으며, 테스트와 구현 피드백이 필요합니다.        |
| 단계 3               | 구현이 권장되는 단계입니다. 제안에 대한 변경은 예상되지 않지만, 웹 호환성 문제로 인해 일부 변경이 있을 수 있습니다. |
| 단계 4               | 제안된 기능이 완성되어 표준에 포함될 준비가 된 단계입니다. 더 이상의 변경은 없습니다.                   |

이 프로세스는 매우 체계적이며, 각 단계마다 특정 기준을 충족해야 다음 단계로 진행할 수 있습니다. 예를 들어, 단계 3으로 진행하려면 완전한 명세 텍스트, 지정된 검토자의 승인, 그리고 관련 편집 그룹의 승인이 필요합니다.

TC39 위원회는 **매년 7월에 새로운 ECMAScript 버전을 발표**하는 것을 목표로 하며, 이를 위한 일정과 절차가 정해져 있습니다.

이 프로세스는 JavaScript 언어의 발전을 체계적이고 신중하게 관리하며, 커뮤니티의 의견을 반영하고 웹 호환성을 유지하면서 새로운 기능을 추가할 수 있도록 합니다.

<br>

## 자바스크립트의 자료형(타입)에는 어떤 것들이 있나요?

자바스크립트의 자료형은 크게 원시 타입과 참조 타입(또는 객체 타입)으로 분류할 수 있습니다. 원시 타입에는 number, string, boolean, undefined, null, symbol, BigInt가 있으며, 이 외의 모든 타입은 객체 타입에 속합니다.

원시 타입의 데이터는 불변값(immutable)이기 때문에 메모리에 저장된 값 자체를 변경할 수 없습니다.  
예를 들어, `let a = "a";`라고 선언하면, 메모리에는 "a"라는 문자열 값이 저장됩니다. 이후 `a = "b";`라고 값을 재할당하면, 기존 문자열 "a"를 "b"로 변경하는 것이 아니라, 새로운 문자열 "b"를 생성하여 변수에 할당합니다.

객체 타입은 변경 가능(mutable)합니다. 즉, 객체의 프로퍼티를 추가, 수정, 삭제할 수 있습니다.

원시 타입과 객체 타입의 차이가 생기는 이유는 객체 타입이 여러 프로퍼티를 모아 놓은 ‘그룹’이기 때문입니다.

추가로 객체 타입을 불변값으로 사용하려면, 깊은 복사를 하거나 Object.defineProperty와 Object.freeze 같은 메서드를 활용하여 객체의 변경을 제한할 수 있습니다.

### 📝 원시 타입
| 타입        | 설명                                                         |
|-----------|------------------------------------------------------------|
| Number    | 숫자를 나타내며, 정수와 실수를 모두 포함합니다.                                |
| String    | 문자열을 나타냅니다. 작은따옴표나 큰따옴표, 백틱으로 표현합니다.                       |
| Boolean   | `true` 또는 `false` 값을 가집니다.                                 |
| Undefined | 변수가 선언되었지만 값이 할당되지 않은 상태를 나타냅니다.                           |
| Null      | 의도적으로 '비어있음'을 나타내는 값입니다.                                   |
| Symbol    | ES6에서 추가된 타입으로, 유일하고 변경 불가능한 원시 값입니다.                      |
| BigInt    | ES11에서 추가된 타입으로, Number의 안전한 정수 표현 범위를 넘어서는 정수를 다룰 수 있습니다. |

<br>

## Document Object Model이란 무엇인가요?

DOM은 문서 객체 모델(Document Object Model)의 약자로, 브라우저의 렌더링 엔진이 HTML 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM을 생성합니다.

DOM은 HTML 문서의 계층적 구조와 정보를 표현하고 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 트리 자료구조입니다.  
DOM은 노드 객체들로 구성되어 있으며, 각 노드의 타입에 따라 DOM API를 제공합니다.

예를 들어, 자바스크립트 코드에서 document.getElementById()와 같은 메서드를 사용하여 특정 HTML 요소를 선택하고, 이 요소의 내용이나 스타일을 변경할 수 있습니다. 이를 통해 개발자는 웹 페이지를 동적으로 업데이트할 수 있습니다.

DOM 조작을 통해 사용자 입력에 따라 페이지의 내용을 변경하거나, 서버에서 받아온 데이터로 페이지를 업데이트하는 등의 작업이 가능합니다.

또한, DOM은 이벤트 처리를 통해 사용자와의 상호작용을 가능하게 만듭니다.  
예를 들어, 클릭, 입력, 스크롤 같은 이벤트를 감지하고, 이를 처리하여 동적인 사용자 경험을 제공합니다.

DOM의 중요성은 브라우저와 스크립트 언어 간의 다리 역할을 한다는 점에서 큽니다.  
이를 통해 개발자는 웹 애플리케이션의 사용자 인터페이스를 보다 유연하게 제어할 수 있습니다.

<br>

## 이벤트 위임이란 무엇인가요? 이벤트 캡쳐링과 이벤트 버블링의 차이점은 무엇인가요?

이벤트 위임은 부모 요소에 하나의 이벤트 리스너를 추가하여 자식 요소의 이벤트를 처리하는 방식입니다.  
예를 들어, 리스트의 각 항목에 클릭 이벤트를 처리하고 싶다면 모든 항목에 이벤트 리스너를 추가하는 것이 아니라 리스트 자체에 이벤트 리스너를 추가하고 클릭 된 요소를 확인하는 방식으로 구현할 수 있습니다.

이러한 이벤트 위임이 가능한 이유는 이벤트 전파 단계 때문입니다.  
이벤트 발생은 이벤트 캡쳐링 전파, 타겟 전파, 버블링 전파 이렇게 세 가지 전파 단계로 나뉩니다.

다음으로, 이벤트 캡쳐링과 이벤트 버블링의 주요 차이점은 이벤트가 전파되는 방향입니다.

이벤트 캡쳐링은 이벤트가 최상위 요소에서 시작하여 이벤트가 발생한 요소까지 내려오는 전파 방식입니다.  
이 전파 단계에서는 이벤트가 루트 요소에서 타겟 요소로 전달됩니다.

이벤트 버블링은 이벤트가 발생한 요소에서 시작하여 상위 요소들로 차례대로 전파되는 과정을 말합니다.  
즉, 이벤트가 타겟 요소에서 시작하여 문서의 최상위 요소까지 거슬러 올라가면서 이벤트가 전달됩니다.  
따라서 부모 요소에 이벤트 리스너를 추가하면 자식 요소에서 발생하는 이벤트를 감지하고 처리할 수 있습니다.

이벤트 리스너를 추가할 때, `addEventListener` 메서드의 세 번째 인수인 `useCapture`를 `true`로 설정하면 캡쳐링 단계에서 이벤트를 처리하도록 지정할 수 있으며, 기본값인 `false`의 경우 버블링 단계에서 이벤트가 처리됩니다.

<br>

## Call by value와 Call by reference의 차이점은 무엇인가요?

값에 의한 전달(Call by value)과 참조에 의한 전달(Call by reference)은 컴퓨터 프로그래밍에서 평가 전략의 종류로,  
함수의 인자에 어떤 값을 전달해 주느냐에 따라 함수가 어떻게 실행될지에 대한 방법을 결정하는 것이라고 할 수 있습니다.

값에 의한 전달은 함수에 값을 전달할 때 값을 복사하여 전달하는 방식입니다.
따라서 함수 내에서 값을 변경하여도, 원본 값은 변하지 않습니다.

반면, 참조에 의한 전달은 함수에 값을 전달할 때 값에 대한 참조 주소를 전달하는 방식입니다.
따라서 함수 내에서 값을 변경한다면, 원본 값이 변경됩니다.

자바스크립트에서 기본형(primitive types)은 call by value로 동작하고, 객체는 call by sharing으로 동작합니다.

### 📝 Call by sharing
- call by value: 인수를 새 메모리 영역에 복사하여 매개 변수에 전달한다.
  - 원본값은 함수 실행 후에도 변하지 않는다.
- call by reference: 인수의 참조(메모리 주소)를 매개 변수에 전달한다.
  - 인자의 원본값이 함수 실행 후에 수정될 수 있다.

```js
function change(ref1, ref2) {
  ref1.data = 'changed';
  ref2 = { data : 'changed' };
}

const obj1 = { data : 'original' };
const obj2 = { data : 'original' };

change(obj1, obj2);

console.log(obj1) // { data : 'changed' }
console.log(obj2) // { data : 'original' }
```
만약  
- 자바스크립트가 call by value로 동작 한다면, obj1은 변경되지 않아야 한다.
- 자바스크립트가 call by reference로 동작 한다면, obj2는 변경되어야 한다.

이는 둘 다 아니라는 얘기다.

이러한 방식을 call by sharing이라고 한다.
call by sharing은 참조값을 직접적으로 전달하는 것이 아닌, 그 주소에 대한 복사본을 만들어 전달한다.

[🔗 도움받은 블로그 글](https://think0wise.tistory.com/65)

<br>
<br>

# React

## 브라우저에 URL을 입력한 순간부터 화면에 웹 페이지가 나타나기까지의 모든 과정을 아는대로 최대한 자세히 설명해보세요.

사용자가 브라우저 주소창에 URL을 입력하면, 먼저 도메인 이름 시스템(DNS) 조회가 시작됩니다.  
DNS는 사용자가 입력한 도메인 이름을 해당 서버의 IP 주소로 변환합니다.

DNS 조회로 IP 주소를 얻은 후, 브라우저는 서버와 TCP/IP 연결을 설정합니다. 이 과정은 3-way 핸드셰이크를 통해 이루어집니다.

만약 HTTPS 프로토콜을 사용하는 경우, TLS 핸드셰이크가 추가로 진행됩니다.  
TLS 핸드셰이크는 클라이언트와 서버 간의 안전한 암호화 통신을 설정하는 과정으로, 인증서 교환 및 세션 키 생성 등을 포함합니다.

연결이 완료되면, 브라우저는 서버에 HTTP 요청을 보냅니다.  
이 요청은 일반적으로 GET 요청으로, 사용자가 요청한 리소스 예를들어 HTML, CSS, JavaScript 파일 등을 가져오도록 서버에 요청합니다.

서버는 요청을 받은 후, 해당 리소스를 처리하여 HTTP 응답을 생성합니다.  
응답에는 상태 코드, 헤더 정보, 그리고 요청된 리소스의 데이터가 포함됩니다.

브라우저는 서버로부터 응답을 수신한 후, 렌더링 프로세스를 시작합니다.

먼저, 브라우저는 HTML을 파싱하여 DOM(Document Object Model) 트리를 생성합니다.

다음으로 CSS 파일을 파싱하여 CSSOM(CSS Object Model) 트리를 생성하고 DOM과 결합되어 렌더 트리를 만듭니다.  
렌더 트리는 페이지의 각 요소가 화면에 어떻게 나타날지를 결정하며, 레이아웃 계산을 통해 각 요소의 크기와 위치를 결정합니다.

렌더 트리에 따라 각 요소가 화면에 그려지는 페인팅 과정이 진행됩니다.  
그런 다음, 여러 레이어로 분리된 요소들을 합성하여 최종적으로 화면에 웹 페이지가 나타나게 됩니다.

HTML 문서에 포함된 JavaScript는 파싱 과정에서 만나게 되면 실행됩니다.  
이때 JavaScript가 DOM을 조작하거나 네트워크 요청을 보내는 등의 동작이 수행될 수 있습니다.

추가적으로, JavaScript는 Ajax나 Fetch API 등을 통해 비동기적으로 데이터를 가져와 화면에 동적으로 콘텐츠를 업데이트할 수도 있습니다.

<br>

## package.json, package-lock.json, node_modules는 무엇인가요?

package.json은 프로젝트의 메타정보와 프로젝트가 의존하고 있는 모듈들에 대한 정보들을 json 형태로 모아놓은 파일입니다.  
package.json에 필요한 패키지들의 목록을 파일로 정리해놓고,  
목록 파일을 이용하여 단 한번의 명령어로 필요한 패키지들을 모두 설치 할 수 있습니다.  
팀 내에서 동일한 개발환경을 구축하려고 할 경우, package.json을 통해 동일한 개발환경을 빠르게 구축할 수 있습니다.

package-lock.json은 프로젝트의 의존성 트리를 정확히 기록하는 파일입니다.  
package.json에 있는 모듈과, 그 모듈들이 의존하고 있는 모든 모듈들을 포함하고 있습니다.  
각 패키지의 정확한 버전과 의존성을 명시하기 때문에, 팀원 간 일관된 개발 환경을 유지하는 데 도움을 줍니다.

node_modules은 프로젝트의 모든 의존성 패키지가 설치되는 디렉토리입니다.  
패키지 설치 명령어를 실행하면 이 디렉토리에 패키지들이 설치됩니다.

### 📝 조사 내용

[package.json](https://docs.npmjs.com/cli/v10/configuring-npm/package-json)
- 스크립트 정의: package.json에는 프로젝트에서 자주 사용하는 명령어를 scripts 항목에 정의할 수 있습니다. 예를 들어, npm start, npm test와 같은 명령어들이 정의되며, 개발 과정에서 반복적으로 사용하는 작업들을 자동화할 수 있습니다.
- 키워드와 저자 정보: keywords를 통해 프로젝트와 관련된 키워드를 정의하여, 검색 엔진 최적화(SEO)에 도움이 될 수 있으며, author나 contributors 필드를 통해 프로젝트의 저자와 기여자를 명시할 수 있습니다.
- 엔진 및 라이선스: engines 필드를 통해 프로젝트가 특정 Node.js 버전에서 작동하도록 요구사항을 설정할 수 있으며, license 필드에는 프로젝트의 사용 및 배포 조건을 명시합니다.

[package-lock.json](https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json)
- 보안 및 무결성: package-lock.json은 각 패키지의 무결성을 검증하기 위해 체크섬을 저장합니다. 이를 통해 패키지가 원본과 일치하는지 확인하여, 보안 문제를 예방할 수 있습니다.
- 최적화된 설치 속도: 이 파일은 의존성 설치 시 의존성 트리를 미리 정의해 설치 과정을 최적화하여, 패키지를 더 빠르게 설치할 수 있습니다.
- 의존성 관리: package-lock.json은 직접 의존성뿐만 아니라, 하위 의존성(의존성의 의존성)까지도 버전을 명확히 기록하여, 의존성의 정확한 버전을 보장합니다.

node_modules
- 캐싱 메커니즘: node_modules 디렉토리는 패키지 설치 시 로컬에 패키지를 저장하여, 동일한 패키지를 반복적으로 설치할 때 **네트워크 요청 없이 로컬 캐시를 사용할 수 있습니다.**
- 폴더 구조: Node.js의 모듈 해상도 방식에 따라, 깊이 중첩된 의존성 구조를 가질 수 있으며, 이를 통해 각각의 패키지가 독립적인 버전을 유지할 수 있습니다.
- 디스크 공간 사용: 의존성 패키지가 많아질수록 디렉토리의 크기가 커질 수 있으며, 개발 환경에서만 사용되는 의존성(예: devDependencies)도 포함됩니다. 이 때문에 배포 시 node_modules를 제외하는 것이 일반적입니다.

<br>

## Client Side Rendering이란 무엇인가요?

클라이언트 사이드 렌더링은 브라우저가 웹 페이지를 렌더링하는 방식 중 하나입니다.

클라이언트 사이드 렌더링 방식으로 구현된 웹 애플리케이션의 경우 브라우저는 서버로부터 거의 비어져 있는 HTML 파일과 자바스크립트 파일을 응답받고 자바스크립트를 통해 동적으로 페이지를 렌더링합니다.

최초 렌더링 시에는 페이지가 로드가 되기까지 시간이 걸리지만, 한 번 로드된 이후로는 페이지를 이동할 경우 새로운 페이지를 다시 불러오는 것이 아닌   필요한 데이터만 서버에서 가져와 페이지의 일부를 다시 렌더링하기 때문에 일반적으로 빠릅니다.

하지만 구글과 같이 검색 사이트에서 사용하는 검색 엔진 크롤러는 JavaScript로 동적 생성된 콘텐츠를 제대로 인식하지 못할 수 있기 때문에 SEO에 불리할 수 있다는 단점이 있습니다.

따라서 클라이언트 사이드 렌더링은 검색 엔진 노출이 중요하지 않은 애플리케이션이나 관리자 시스템에 주로 사용됩니다.

<br>

## Single Page Application이란 무엇인가요?

Single Page Application, 줄여서 SPA는 사용자 인터페이스(UI)가 단일 HTML 페이지로 구성되어 있어 전체 페이지를 새로 로드하지 않고도 페이지 간의 전환이 이루어지는 웹 애플리케이션입니다. SPA는 사용자의 상호작용에 따라 필요한 데이터와 뷰를 동적으로 업데이트하여 더 나은 사용자 경험을 제공합니다.

SPA는 클라이언트 사이드 라우팅을 사용하여 URL 변경 없이 애플리케이션의 상태를 관리합니다. 이를 통해 브라우저의 주소 표시줄에 URL이 표시되면서도 페이지를 새로 로드하지 않고 콘텐츠를 변경할 수 있습니다.

SPA는 초기 로딩 시에 필요한 최소한의 HTML, CSS, JavaScript 파일만 서버로부터 가져오고, 이후에는 클라이언트 측에서 API를 통해 서버와 상호작용합니다. 서버는 보통 JSON 형식으로 데이터를 반환하며, 클라이언트는 이를 처리하여 화면에 표시합니다.

SPA는 종종 React, Angular, Vue.js와 같은 자바스크립트 프레임워크나 라이브러리를 사용하여 UI를 구성하고 상태를 관리합니다. 이러한 도구들은 복잡한 사용자 인터페이스를 효율적으로 관리하고, 상태 변경을 쉽게 처리할 수 있도록 도와줍니다.

<br>

## 상태 변화에 대해 React는 어떻게 반응할까요?

리액트에서 상태를 업데이트하는 방법으로는 `setState` 또는 상태 업데이트 함수를 호출하는 것이 있습니다. 상태가 변경되면 React는 해당 컴포넌트를 리렌더링합니다. React는 실제 DOM을 직접 업데이트하지 않고, 가상 DOM을 사용하여 변경 사항을 관리합니다.

React는 비교 알고리즘을 통해 이전 가상 DOM과 새로운 가상 DOM을 비교하여 차이점(diff)을 계산합니다. 이 과정을 재조정(Reconciliation)이라고 합니다.

새로운 렌더링 결과를 가상 DOM에 업데이트한 후, 이전 가상 DOM과 비교하여 실제 DOM에 필요한 최소한의 변경만을 수행합니다. 이 과정에서 최소한의 DOM 조작이 이루어지며, 사용자에게 빠르고 부드러운 UI를 제공합니다.

<br>

## 리액트의 Strict Mode는 어떤 역할을 하는 것인지 최대한 자세히 설명해보세요.

React의 Strict Mode는 애플리케이션 내의 잠재적인 문제를 식별하는 데 도움을 주는 개발 모드 전용 도구입니다.  
이는 실제 프로덕션 빌드에는 영향을 미치지 않으며, 개발 과정에서 일반적인 버그를 빠르게 찾을 수 있도록 합니다.

Strict Mode는 `<StrictMode>` 컴포넌트 내부의 모든 컴포넌트 트리에 대해 추가적인 개발 전용 검사를 활성화합니다.

전체 앱에 대한 Strict Mode를 활성화하려면 렌더링할 때 루트 컴포넌트를 `<StrictMode>`로 래핑하면 되고, 특정 컴포넌트를 `<StrictMode>` 컴포넌트로 감싸 일부분에만 Strict Mode를 활성화할 수도 있습니다.

리액트는 작성하는 모든 컴포넌트가 순수 함수라 가정하기 때문에 리액트 컴포넌트는 항상 동일한 입력에 대해 동일한 JSX를 반환해야 합니다.  
Strict Mode는 컴포넌트 함수 본문과 `useState`, `set` 함수, `useMemo` 또는 `useReducer`에 전달한 함수를 이중으로 호출함으로써 사이트 이펙트가 있는 코드를 쉽게 발견할 수 있게 해줍니다.

또한 개발 모드에서 effect를 다시 실행하여 정리(cleanup) 함수가 제대로 구현되었는지 확인합니다.  
이는 메모리 누수나 무한 루프와 같은 문제를 미리 방지하는 데 도움이 됩니다.
