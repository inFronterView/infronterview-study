# 목차

- JavaScript
    - [var,let,const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.](#varletconst의-차이점-그리고-사용-컨벤션에-대해-최대한-자세히-설명해보세요)
    - [자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?](#자바스크립트는-싱글-스레드라고-합니다-스레드란-무엇인가요-브라우저도-싱글-스레드일까요)
    - [자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?](#자바스크립트에는-다양한-고차함수-형식의-메소드가-있습니다-고차함수의-장점은-무엇일까요)
    - [자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.](#자바스크립트의-trycatch의-기본적인-작동방식-그리고-언제-어떤-경우에-사용해야-하는지-조사해보세요)
    - [프로미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.](#프로미스를-사용하는-이유는-무엇인지-최대한-자세히-설명해보세요)
    - [자바스크립트의 Strict Mode에 대해 설명해보세요.](#자바스크립트의-strict-mode에-대해-설명해보세요)
    - [렉시컬 환경과 렉시컬 스코프란 무엇인가요?](#렉시컬-환경과-렉시컬-스코프란-무엇인가요)
    - [0.1 + 0.2 === 0.3는 왜 false인가요?](#010203는-왜false인가요)
- React
    - [리액트의 상태 끌어올리기는 어떤 단점이 있을까요?](#리액트의-상태-끌어올리기는-어떤-단점이-있을까요)
    - [가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?](#가상돔이라는-존재는-무엇이며-장점과-단점은-어떤-것들이-있을까요)
    - [리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.](#리액트의-diffing-algorithm의-내부-로직에-대해서-최대한-자세히-설명해보세요)
    - [리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?](#리액트의-상태-업데이트는-비동기로-실행됩니다-이-말은-무슨-뜻이며-왜-그럴까요)
    - [리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?](#리액트-컴포넌트-내부에서-모든-함수를usecallback으로-감싸는-것이-좋을까요)

<br>

# JavaScript

## var, let, const의 차이점, 그리고 사용 컨벤션에 대해 최대한 자세히 설명해보세요.

먼저, var로 선언된 변수는 함수 스코프를 가집니다. 이는 변수가 선언된 함수 내에서만 지역 변수로 인식된다는 의미입니다.  
함수 외부에서 선언된 var 변수는 전역 스코프를 가지게 됩니다.

var로 전역 스코프에서 변수를 선언하면 이는 전역 객체의 프로퍼티가 됩니다.  
브라우저 환경에서는 window 객체, Node.js 환경에서는 global 객체의 프로퍼티가 되는 것이죠.  
이런 특성은 의도치 않은 전역 변수 오염을 일으킬 수 있어 주의가 필요합니다.

두 번째로, var는 호이스팅이라는 특성을 가집니다.  
이로 인해 변수 선언이 스코프의 최상단으로 끌어올려지는 것처럼 동작합니다.  
var 변수는 호이스팅될 때 `undefined`로 초기화되며, 이로 인해 변수를 실제로 선언하기 전에 참조할 수 있습니다.  
하지만 값의 할당은 원래 코드에 작성된 위치에서 이루어집니다.

또한, var로 선언한 변수는 같은 스코프 내에서 같은 이름으로 재선언이 가능합니다.  
이는 편리할 수 있지만, 의도치 않게 변수를 덮어쓰는 문제를 일으킬 수 있어 주의가 필요합니다.

let과 const는 var와 달리 블록 스코프를 가집니다.  
이 두 키워드로 선언된 변수는 중괄호({})로 둘러싸인 블록 내에서만 유효합니다.

let과 const도 호이스팅이 발생하지만, 변수가 선언된 위치에서 실제로 초기화되기 전까지는 접근할 수 없습니다.  
이러한 현상을 TDZ(Temporal Dead Zone, 일시적 사각지대)라고 합니다.

또한, let과 const로 선언된 변수는 같은 스코프 내에서 같은 식별자로 재선언할 수 없습니다.  
그리고 이들을 전역 스코프에서 선언해도 전역 객체 예를 들어 브라우저의 경우 window의 프로퍼티가 되지 않습니다.

let과 const의 주요 차이점은 재할당 가능 여부입니다.  
let으로 선언된 변수는 재할당이 가능하지만, const로 선언된 변수는 재할당이 불가능합니다. 따라서 const로 선언된 변수는 반드시 선언과 동시에 초기화가 이루어져야 합니다.

ES6에 let과 const 키워드가 생기면서 var의 사용은 지양되고 있습니다.  
함수 스코프와 호이스팅으로 인해 예기치 않은 버그를 발생할 수 있기 때문입니다.

let과 const 중 const를 우선 사용하는 것이 권장됩니다. 변수의 값이 재할당 되지 않는다면 const를 사용합니다.  
이는 코드의 의도를 명확히 하고 실수로 인한 재할당을 방지합니다. 따라서 let은 필요할 때만 사용합니다.

상수의 경우 대문자와 언더스코어를 사용하여 변수를 선언합니다.

<br>

### 📝 var로 선언한 변수와 변수 키워드 없이 선언한 변수의 차이점

```js
var a = "a";
console.log(window.a); // "a"

b = "b";
console.log(window.b); // "b"
```

🧐 이 둘은 뭐가 다를까?

1. `var a = "a";`로 선언된 변수

- `delete` 키워드로 삭제할 수 없습니다.
- `delete window.a;`를 실행해도 a는 삭제되지 않습니다.

2. `b = "b";`로 선언된 변수

- `delete` 키워드로 삭제할 수 있습니다.
- `delete window.b;`를 실행하면 b가 전역 객체에서 삭제됩니다.

이 차이를 코드로 확인해보겠습니다.
```js
var a = "a";
b = "b";

console.log(window.a); // "a"
console.log(window.b); // "b"

delete window.a;
delete window.b;

console.log(window.a); // "a" (삭제되지 않음)
console.log(window.b); // undefined (삭제됨)
```

이 차이가 발생하는 이유는 다음과 같습니다.
- var로 선언된 변수는 변수 선언의 결과로 생성되며, 전역 객체의 특성(property)으로 추가되지만 설정자(configurable) 속성이 false로 설정됩니다.
- 키워드 없이 선언된 변수는 전역 객체에 직접 추가되는 특성으로 취급되며, 설정자 속성이 true로 설정됩니다.

```js
console.log(Object.getOwnPropertyDescriptor(window, "a"));
console.log(Object.getOwnPropertyDescriptor(window, "b"));
```

```
{
  value: "a",
  writable: true,
  enumerable: true,
  configurable: false  // var로 선언된 변수는 configurable이 false입니다.
}

{
  value: "b",
  writable: true,
  enumerable: true,
  configurable: true   // 키워드 없이 선언된 변수는 configurable이 true입니다.
}
```

이러한 차이 때문에 var로 선언된 변수는 더 안전하고 예측 가능한 동작을 보입니다.  
반면, 키워드 없이 선언된 변수는 의도치 않게 삭제될 수 있어 잠재적인 버그의 원인이 될 수 있습니다.

<br>

## 자바스크립트는 싱글 스레드라고 합니다. 스레드란 무엇인가요? 브라우저도 싱글 스레드일까요?

스레드는 하나의 프로세스 내에서 실행되는 독립적인 실행 흐름을 의미합니다.  
자바스크립트는 기본적으로 싱글 스레드 언어입니다. 이는 한 번에 하나의 작업만 수행할 수 있다는 뜻입니다.  
자바스크립트 엔진은 하나의 호출 스택을 가지고 있어, 코드를 순차적으로 실행합니다.

브라우저의 경우 멀티 프로세스이면서 동시에 멀티 스레드이지만 자바스크립트 실행 환경에 한정해서는 싱글 스레드로 동작합니다.

<br>

### 📝 동기 처리와 비동기 처리

현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식을 동기 처리라고 합니다.  
- 실행 순서가 보장되지만, 앞선 태스크가 종료될 때까지 이후 태스크들이 블로킹 됩니다.
- 동기 처리는 코드의 실행 흐름을 예측하기 쉽지만, 시간이 오래 걸리는 작업이 있을 경우 전체적인 프로그램의 실행 속도가 느려질 수 있습니다.

현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기 처리라고 합니다.  
- 비동기 처리는 여러 작업을 동시에 처리할 수 있어 효율적이지만, 코드의 실행 순서를 관리하기가 더 복잡할 수 있습니다.  
- ex) setTimeout, setInterval, HTTP 요청, 이벤트 핸들러

<br>

### 📝 프로그램, 프로세스, 스레드

프로그램
- 프로그램은 특정 작업을 수행하기 위해 작성된 명령어들의 집합입니다.
- 실행 파일이나 스크립트 형태로 존재하며, 실행되기 전까지는 디스크와 같은 저장 매체에 저장되어 있습니다.


프로세스
- 프로세스는 운영 체제에 의해 관리되는 실행 중인 프로그램의 단위입니다.
- 각 프로세스는 운영 체제로부터 메모리 공간과 기타 시스템 리소스를 할당받습니다.
- 중요한 점은 프로세스가 CPU 시간을 할당받는다는 것입니다. 운영 체제의 스케줄러는 여러 프로세스 간에 CPU 시간을 분배하여 각 프로세스가 실행될 수 있도록 관리합니다.
- 멀티태스킹 환경에서는 여러 프로세스가 번갈아가며 CPU를 사용하는데, 이를 통해 동시에 여러 작업이 실행되는 것처럼 보이게 됩니다.


스레드
- 스레드는 프로세스 내에서 실행되는 가장 작은 실행 단위입니다.
- 한 프로세스는 여러 스레드를 가질 수 있으며, 이들은 프로세스의 리소스를 공유합니다.
- 스레드 역시 CPU 시간을 할당받습니다. 멀티스레딩 환경에서는 한 프로세스 내의 여러 스레드가 CPU 시간을 나누어 사용합니다.
- 스레드 간 전환은 프로세스 간 전환보다 일반적으로 더 빠르고 효율적입니다, 왜냐하면 스레드들은 같은 프로세스 내의 리소스를 공유하기 때문입니다.

<br>

## 자바스크립트에는 다양한 고차함수 형식의 메소드가 있습니다. 고차함수의 장점은 무엇일까요?

자바스크립트의 고차 함수는 다섯 가지 주요 장점을 가지고 있습니다.

첫째, 공통 로직을 함수로 분리하여 여러 곳에서 재사용할 수 있기 때문에 코드의 추상화와 재사용성을 높여줍니다.

둘째, 복잡한 로직을 더 명확하고 간결하게 표현할 수 있어 코드 이해가 쉬워지므로 가독성과 간결성을 개선합니다.

셋째, 불변성과 순수 함수를 쉽게 구현할 수 있어 코드의 예측 가능성이 높아지기 때문에 함수형 프로그래밍을 지원합니다.

넷째, Promise나 콜백 함수를 다룰 때 코드 구조를 더 깔끔하게 만들 수 있어 비동기 처리를 용이하게 합니다.

마지막으로, 작은 단위의 함수로 로직을 분리하면 각 부분을 독립적으로 테스트하기 쉬워지므로 테스트하기 쉬운 코드 작성을 가능하게 합니다.

<br>

## 자바스크립트의 try..catch의 기본적인 작동방식, 그리고 언제 어떤 경우에 사용해야 하는지 조사해보세요.

`try..catch` 문은 자바스크립트에서 에러를 처리하는 중요한 구문입니다.  
기본적으로 `try` 블록과 `catch` 블록으로 구성되어 있습니다.

`try` 블록에는 실행하고자 하는 코드를 작성합니다. 이 코드를 실행하다가 에러가 발생하면, 즉시 실행을 멈추고 `catch` 블록으로 넘어갑니다.  
`catch` 블록에서는 이 에러를 처리하는 코드를 작성합니다. 여기서 에러 객체를 받아 에러의 종류나 메시지를 확인할 수 있습니다.  
추가로 `finally` 블록을 사용할 수도 있는데, 이 블록은 `try`나 `catch` 블록의 실행 여부와 상관없이 항상 실행됩니다.

`try..catch` 문은 주로 에러가 발생할 가능성이 있는 상황에서 사용합니다.  
에러 핸들링을 하지 않을 경우 프로그램이 비정상적으로 종료되기 때문에 `try..catch`문을 사용하면 안전하게 에러를 처리할 수 있습니다.

<br>

## 프로미스를 사용하는 이유는 무엇인지 최대한 자세히 설명해보세요.

우선 프로미스란 비동기 작업에 대한 결과 즉, 성공 혹은 실패에 대해 알려줄 것이라는 약속을 의미하는 객체입니다.

콜백 함수를 이용한 상황에서는 비동기 함수의 반환값을 받을 수 없으므로, 동기 함수처럼 반환값을 지정해줄 수 없었습니다.  
하지만 프로미스 객체는 **반환값**이 있으므로, 이 반환값을 통해 비동기 작업도 동기적 코드의 흐름과 유사하게 제어할 수 있습니다.

일반적인 콜백 패턴에서는 콜백 함수의 매개변수로 에러에 대한 데이터를 받고 그에 대한 존재여부를 판단하여 에러 핸들링을 수행합니다.  
**동기 흐름의 에러 핸들링은 콜백 패턴과는 완전히 다릅니다.**

동기적으로 실행되는 코드는 `try..catch` 구문을 이용해 에러에 대한 대처를 할 수 있습니다.  
`try`구문 내에서 발생하는 모든 에러는 `catch` 구문으로 넘겨지도록 설계되어 있습니다.

프로미스는 이와 유사한 흐름으로 에러 핸들링 기능이 설계되어 있습니다.  
`then`과 `catch` 메서드를 통해 `try..catch` 문과 유사한 흐름의 에러 핸들링을 할 수 있을 뿐만 아니라  
**성공 로직과 실패 로직의 분리**를 더욱 명확하게 할 수 있습니다.

마지막으로 프로미스는 객체 지향 프로그래밍의 원칙을 따라 설계되었기 때문에,  
Promise 프로토타입에 새로운 메서드를 추가하거나 기존 메서드를 확장하는 등 **유연한 확장**이 가능합니다. 

이를 통해 Promise 객체의 기능을 커스터마이징하고, 기존 메서드들과 함께 체이닝 방식으로 사용할 수 있어 유연한 비동기 프로그래밍이 가능해집니다.

<br>

## 자바스크립트의 Strict Mode에 대해 설명해보세요.

자바스크립트의 Strict Mode는 코드를 더 엄격하게 실행하는 방식입니다.  
이를 사용하면 더 안전하고 오류가 적은 코드를 작성할 수 있습니다.

Strict Mode를 사용하려면 코드 최상단이나 함수 본문의 시작 부분에 `'use strict'`라는 문자열을 선언하면 됩니다.  
이렇게 하면 자바스크립트 엔진이 코드를 더 엄격하게 해석하고 실행합니다.

Strict Mode의 주요 특징은 다음과 같습니다.  
먼저, 선언되지 않은 변수를 사용하면 에러가 발생합니다. 이는 변수 이름을 잘못 입력하는 실수를 방지해줍니다.

또한, 삭제할 수 없는 속성을 삭제하려고 하면 에러가 발생합니다.  
예를 들어 `Object.prototype`을 삭제하려고 하면 에러가 발생합니다.

함수 내에서 `this`의 값도 달라집니다.  
일반 함수 호출 시 `this`는 전역 객체인 `window`를 가리키지만 strict mode에서는 `this`가 `undefined`가 되어, 실수로 전역 객체를 참조하는 것을 방지할 수 있습니다.

중복된 매개변수 이름을 사용할 수 없고, 8진수 문법도 사용할 수 없습니다.

이러한 특징들로 인해 Strict Mode는 여러 가지 장점을 제공합니다.  
코드의 오류를 줄이고, 디버깅을 쉽게 만들며, 보안을 강화합니다.  
또한 미래의 자바스크립트 버전과의 호환성도 높여줍니다.

<br>

## 렉시컬 환경과 렉시컬 스코프란 무엇인가요?

렉시컬 스코프란 함수가 어디서 호출 되었는지가 아닌 어디서 정의되었는지에 따라 그 함수의 스코프가 결정되는 것 입니다.   
즉, 코드가 작성된 '정적인 위치'에 따라 스코프가 결정되는 것입니다.

이 렉시컬 환경은 해당 스코프 내의 변수나 함수명 같은 식별자들과 그 값들을 저장하는 자료 구조라고 볼 수 있습니다.  
렉시컬 환경은 또한 외부 렉시컬 환경에 대한 참조를 가지고 있어, 이를 통해 스코프 체인을 형성합니다.  
이로 인해 내부 함수에서 외부 함수의 변수에 접근할 수 있습니다.

이러한 렉시컬 스코프와 렉시컬 환경의 개념은 클로저와 밀접한 관련이 있습니다.  
클로저는 함수가 자신이 선언됐을 때의 렉시컬 환경을 기억하고 있다가, 나중에 그 환경 밖에서 실행되더라도 해당 환경에 접근할 수 있는 현상을 말합니다.

<br>

## `0.1 + 0.2 === 0.3`는 왜 `false`인가요?

자바스크립트에서 `0.1 + 0.2 === 0.3`가 false로 평가되는 이유는 자바스크립트의 number 타입이 부동 소수점 형식을 사용하기 때문입니다.  
부동 소수점이란 ‘소수점이 움직인다’라는 의미로 고정 소수점의 반대 개념입니다.

EcmaScript 사양에 따르면, 숫자 타입의 값은 64비트 배정밀도 부동 소수점 형식을 따릅니다.

64비트 배정밀도 부동 소수점 방식은 메모리를 **부호 비트, 지수부, 가수부**로 나누어서 실수를 저장합니다.  
(부호부 1비트, 지수부 11비트, 가수부 52비트로 구성되어 있음)

컴퓨터는 2진법을 사용하여 숫자를 표현합니다.  
따라서 10진수를 2진수로 변환해야 하는데, 이 때 정수 부분과 소수 부분을 변환하는 방법이 다릅니다.

소수의 경우, 소수 부분에 2를 곱한 뒤 값의 정수 부분을 기록하고, 곱한 값이 1이 될 때까지 반복합니다.  
만약 곱한 값이 1을 초과하면 정수 부분을 버리고 다시 소수 부분을 곱합니다.

10진법의 소수를 정확히 2진법으로 표현할 경우 딱 떨어지는 값이 아닌 무한이기 때문에 근사값으로 저장되고
따라서 0.1과 0.2를 더하면 정확히 0.3이 아닌 아주 작은 오차가 있는 값이 나오게 됩니다.

따라서 일치 연산자로 비교하면 `false`가 반환 됩니다.

[🔗 도움받은 블로그 글](https://blog.naver.com/kmc7468/220990920730)

<br>
<br>

# React

## 리액트의 상태 끌어올리기는 어떤 단점이 있을까요?

상태 끌어올리기는 리액트에서 자주 사용되는 패턴이지만, 몇 가지 단점이 있습니다.

첫째, 프롭스 드릴링(Props Drilling) 문제가 발생할 수 있습니다.
상태를 상위 컴포넌트로 끌어올리면, 그 상태를 필요로 하는 하위 컴포넌트까지 여러 단계를 거쳐 프롭스를 전달해야 할 수 있습니다. 이는 코드의 가독성을 떨어뜨리고, 유지보수를 어렵게 만듭니다.

둘째, 컴포넌트 간의 결합도가 높아질 수 있습니다.
여러 컴포넌트가 동일한 상태에 의존하게 되면, 한 컴포넌트의 변경이 다른 컴포넌트에 영향을 미칠 수 있어 컴포넌트의 재사용성과 독립성이 저하될 수 있습니다.

셋째, 상위 컴포넌트의 복잡도가 증가합니다.
여러 하위 컴포넌트의 상태를 관리하게 되면, 상위 컴포넌트의 로직이 복잡해지고 비대해질 수 있습니다. 이는 단일 책임 원칙을 위배할 수 있습니다.

넷째, 성능 문제가 발생할 수 있습니다.
상태가 변경될 때마다 그 상태를 사용하는 모든 하위 컴포넌트가 리렌더링될 수 있어, 불필요한 렌더링이 발생할 수 있습니다.

다섯째, 상태 관리의 복잡성이 증가합니다.
애플리케이션의 규모가 커질수록 상태 끌어올리기만으로는 효율적인 상태 관리가 어려워질 수 있습니다. 이는 결국 별도의 상태 관리 라이브러리의 도입으로 이어질 수 있습니다.

마지막으로, 컴포넌트의 재사용성이 떨어질 수 있습니다.
상태가 상위 컴포넌트에 있다면, 하위 컴포넌트를 다른 컨텍스트에서 재사용하기 어려워질 수 있습니다.

이러한 단점들을 고려할 때, 상태 끌어올리기는 적절한 상황에서 신중하게 사용해야 합니다. 대안으로 Context API, 컴포지션 패턴, 또는 상태 관리 라이브러리 사용 등을 고려해볼 수 있습니다.

<br>

## 가상돔이라는 존재는 무엇이며, 장점과 단점은 어떤 것들이 있을까요?

가상 DOM은 실제 DOM의 경량화된 복사본이라고 할 수 있습니다.  
이는 웹 페이지의 DOM 구조를 메모리상에 가상으로 표현한 것입니다.

가상 DOM의 주요 장점으로는 먼저 성능 향상을 들 수 있습니다.  
실제 DOM 조작은 비용이 크지만, 가상 DOM은 메모리상에서 빠르게 처리할 수 있기 때문입니다.  
또한 변경사항을 일괄적으로 처리하여 실제 DOM에 한 번에 적용함으로써 불필요한 렌더링을 최소화할 수 있습니다.

다음으로 크로스 플랫폼 지원을 들 수 있습니다.  
가상 DOM은 실제 DOM에 의존하지 않아서 웹, 모바일 앱, 데스크톱 앱과 같은 다양한 환경에서도 사용할 수 있습니다.

마지막으로 개발자 친화적인 API를 제공합니다.  
개발자가 DOM을 직접 조작하지 않고 원하는 상태만 선언하는 선언적 프로그래밍 방식을 가능하게 합니다.

하지만 단점도 있습니다.  
추가적인 메모리를 사용한다는 점, 간단한 앱에서는 오히려 복잡성을 증가시킬 수 있다는 점, 그리고 관련 개념을 이해하는 데 시간이 필요하다는 점 등이 있습니다.

<br>

## 리액트의 Diffing Algorithm의 내부 로직에 대해서 최대한 자세히 설명해보세요.

React의 Diffing Algorithm은 UI 업데이트를 효율적으로 처리하는 핵심 기술입니다.  
이 알고리즘의 주요 목적은 최소한의 DOM 조작으로 UI를 최신 상태로 유지하는 것입니다.

알고리즘의 기본 원리는 두 가지 가정에서 시작합니다.  
첫째, 다른 타입의 엘리먼트는 다른 트리를 만들 것이라는 것  
둘째, 개발자가 key prop을 통해 안정적인 엘리먼트를 알려줄 수 있다는 것입니다.

Diffing 과정은 트리의 루트부터 시작합니다.

먼저 루트 엘리먼트의 타입을 비교합니다.   
타입이 다르면, 예를 들어 `<div>`에서 `<span>`으로 바뀌면, 이전 트리를 버리고 새로 만듭니다.  
타입이 같으면, DOM 엘리먼트인지 컴포넌트인지에 따라 다르게 처리합니다.

DOM 엘리먼트면 속성만 업데이트하고, 컴포넌트면 인스턴스를 유지하면서 props를 업데이트합니다.  
자식 엘리먼트를 처리할 때는 key가 중요해집니다. key를 이용해 효율적으로 재정렬을 처리할 수 있기 때문입니다.  
특히 동적 리스트에서 key의 역할이 중요합니다. key를 통해 React는 어떤 아이템이 추가, 제거, 재정렬됐는지 빠르게 파악할 수 있습니다.

마지막으로 속성(props)을 비교합니다. 변경된 속성만 업데이트합니다.

이 알고리즘 덕분에 React는 O(n) 복잡도로 매우 빠르게 동작합니다.

<br>

## 리액트의 상태 업데이트는 비동기로 실행됩니다. 이 말은 무슨 뜻이며, 왜 그럴까요?

리액트의 상태 업데이트가 비동기로 실행된다는 것은 상태를 변경하는 함수를 호출했을 때 즉시 상태가 업데이트되지 않는다는 의미입니다.  
이는 성능 최적화를 위한 리액트의 중요한 특징입니다.

리액트가 이렇게 동작하는 주요 이유는 불필요한 렌더링을 방지하고 성능을 향상시키기 위해서입니다.

이를 위해 리액트는 배치(batch) 처리라는 기술을 사용합니다.

배치 처리란 여러 상태 업데이트를 그룹화하여 한 번에 처리하는 것을 말합니다.  
예를 들어, 하나의 이벤트 핸들러 내에서 여러 번 상태를 업데이트하는 경우, 리액트는 이를 모아서 한 번의 리렌더링으로 처리합니다.  
이는 불필요한 계산과 DOM 조작을 줄여 애플리케이션의 전반적인 성능을 개선합니다.

<br>

## 리액트 컴포넌트 내부에서 모든 함수를 useCallback으로 감싸는 것이 좋을까요?

리액트 컴포넌트 내부의 모든 함수를 useCallback으로 감싸는 것이 항상 좋은 방법은 아닙니다.

useCallback은 함수를 메모이제이션, 즉 캐싱하는 훅입니다.  
이는 불필요한 리렌더링을 방지하는 데 도움이 될 수 있지만, 무분별하게 사용하면 오히려 성능에 악영향을 줄 수 있습니다.

useCallback은 주로 React.memo와 함께 사용될 때 가장 효과적입니다.

React는 일반적으로 부모 컴포넌트가 리렌더링되면 모든 자식 컴포넌트도 재귀적으로 리렌더링합니다.  
컴포넌트가 리렌더링될 때마다 그 안의 함수들은 새롭게 생성됩니다.  
useCallback은 이러한 함수들이 불필요하게 새로 생성되는 것을 방지합니다.

React.memo는 컴포넌트를 메모이제이션하여, props가 변경되지 않았다면 리렌더링을 방지합니다.  
이 때 props의 변경은 Object.is 비교를 통해 파악합니다.

따라서 부모 컴포넌트에서 리렌더링이 트리거 됐을 경우, useCallback의 의존성이 변하지 않으면 캐싱한 함수의 참조값을 그대로 사용합니다.  
그렇다면 React.memo로 캐싱된 자식 컴포넌트에서는 props로 전해진 함수가 변경되지 않음을 파악할 수 있어 자식 컴포넌트는 리렌더링 되지 않습니다.

만약 자식 컴포넌트에서 React.memo를 사용하지 않거나, 해당 함수가 자주 변경되는 의존성을 가지고 있다면 부모 컴포넌트에서의 useCallback 사용은 큰 이점이 없을 수 있습니다.  
왜냐하면 useCallback을 통해 함수를 캐싱하는데 비용이 들어가기 때문입니다.

따라서 단순히 모든 함수를 useCallback으로 감싸는 것은 오히려 메모리 사용량을 증가시키고 성능을 저하시킬 수 있습니다.
