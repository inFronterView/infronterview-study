# 목차

- JavaScript
  - [가비지 컬렉터란 무엇이며, 작동 원리에 대해 아는대로 최대한 자세히 설명해보세요.](#가비지-컬렉터란-무엇이며-작동-원리에-대해-아는대로-최대한-자세히-설명해보세요)
  - [메모리 누수란 무엇이며, 자바스크립트에서는 어떤 경우에 발생할 수 있을까요?](#메모리-누수란-무엇이며-자바스크립트에서는-어떤-경우에-발생할-수-있을까요)
  - [자바스크립트는 누가 언제 어디서 왜 만들었나요?](#자바스크립트는-누가-언제-어디서-왜-만들었나요)
  - [자바스크립트는 왜 싱글 스레드일까요?](#자바스크립트는-왜-싱글-스레드일까요)
  - [재귀함수의 장점과 단점은 어떤 것들이 있을까요?](#재귀함수의-장점과-단점은-어떤-것들이-있을까요)
  - [재귀 방식과 iterative 방식의 장단점은 무엇인가요?](#재귀-방식과-iterative-방식의-장단점은-무엇인가요)
- React
  - [제어 컴포넌트와 비제어 컴포넌트](#제어-컴포넌트와-비제어-컴포넌트)

<br>

# Javascript

## 가비지 컬렉터란 무엇이며, 작동 원리에 대해 아는대로 최대한 자세히 설명해보세요.

가비지 컬렉션은 프로그램 실행 중 더 이상 사용되지 않는 메모리를 자동으로 식별하고 해제하는 메모리 관리 시스템이고, 가비지 컬렉터(Garbage Collector)는 이 가비지 컬렉션을 수행하는 프로그램 또는 알고리즘을 지칭합니다.

가비지 컬렉터의 작동 원리는 크게 두 가지 방식이 있는데, 참조 카운팅과 추적 기반 수집입니다.

참조 카운팅은 각 객체마다 참조 횟수를 기록하며, 참조가 생길 때마다 카운트가 증가하고 참조가 제거될 때마다 감소합니다.
카운트가 0이 되면 해당 객체는 가비지로 간주되어 메모리가 해제됩니다.
객체가 불필요해지는 즉시 메모리를 해제할 수 있어 즉각적인 메모리 관리가 가능하다는 장점이 있지만, 객체들이 서로를 참조하는 경우, 실제로는 사용되지 않아도 참조 카운트가 0이 되지 않아 메모리 누수가 발생하는 단점이 있습니다.

다음으로는 추적 기반 수집 방식입니다. 대표 적인 예로 마크 앤 스윕 알고리즘이 있습니다.
루트에서 시작해 접근 가능한 모든 객체를 찾아 마킹하고 그 다음 마킹되지 않은 객체들을 모두 메모리 해제하는 스윕과정을 거칩니다.
이는 객체 간 순환 참조 문제를 해결할 수 있습니다. 하지만 전체 메모리를 탐색해야 하므로 큰 메모리를 사용하는 프로그램에서는 성능 저하가 나타나는 stop-the-world 문제가 발생합니다.

이러한 기술로 프로그래머는 메모리 해제를 직접적으로 할 필요가 없어졌지만 메모리 누수를 일으킬 수 있는 상황을 인지하고 그를 예방할 수 있는 코드를 작성하는 것이 중요하다고 생각합니다.

### 📝 자바스크립트 V8 엔진의 가비지 컬렉터 작동 원리

자바스크립트 v8 엔진은 힙 메모리에는 New Space와 Old Space가 있고 이곳에서 가비지 컬렉션이 일어납니다. 이는 대부분의 객체가 생성 직후 빠르게 불필요해진다는 '세대별 가설'에 기반합니다.

New Space에서는 스캐빈저(Scavenger)라고 불리는 마이너 가비지 컬렉션이 발생합니다. 

New Space를 From space와 To space로 나눕니다. 새 객체는 From space에 할당됩니다. 가비지 컬렉션 발생 시, 살아있는 객체를 To space로 복사합니다. 복사 후 From space와 To space의 역할을 바꿉니다. 두 번의 가비지 컬렌션 사이클에서 살아남은 객체는 Old Space로 이동합니다.

Old Space에서는 Mark-Sweep-Compact 알고리즘을 사용하는 메이저 가비지 컬렉션이 발생합니다.

루트에서 시작해 참조된 모든 객체를 표시하는 마킹 단계 후, 표시되지 않은 객체를 메모리에서 해제하는 스윕 단계가 일어납니다. 그 후 메모리 단편화를 줄이기 위해 살아남은 객체들을 연속된 메모리 공간으로 모으는 컴팩트 단계를 거칩니다.

최근에는 가비지 컬렉션으로 인한 성능 저하를 최소화하기 위해 병렬 가비지 컬렉션, 점진적 가비지 컬렉션, 동시 가비지 컬렉션 같은 여러 최적화 기법이 도입되고 있습니다.

참고 블로그 글: [카카오 FE 기술 블로그](https://fe-developers.kakaoent.com/2022/220519-garbage-collection/)

<br>

## 메모리 누수란 무엇이며, 자바스크립트에서는 어떤 경우에 발생할 수 있을까요?

더 이상 필요하지 않은 메모리를 제대로 해제하지 못해, 해당 메모리가 지속적으로 점유되는 문제를 메모리 누수라고 합니다.

JavaScript에서는 메모리 관리가 자동으로 이루어지지만, 잘못된 코드를 작성하면 메모리 누수가 발생할 수 있습니다.

과도한 전역 변수 사용, 제거되지 않은 타이머, 삭제된 DOM 요소에 대한 참조 유지, 제거되지 않은 이벤트 리스너, 불필요한 외부 변수를 참조하는 클로저는 메모리 누수 발생 원인이 될 수 있습니다.

<br>

## 자바스크립트는 누가 언제 어디서 왜 만들었나요?

자바스크립트는 1995년 넷스케이프 사의 개발자인 브레던 아이크에 의해 개발되었습니다.

브라우저 시장 경쟁에서 우위를 점하기 위해 혁신적 기능이 필요했는데 당시 브라우저는 대부분 정적이었고, 사용자와의 상호작용이 제한적이었습니다. 때문에 브레던 아이크는 넷스케이프의 브라우저에서 동적인 컨텐츠를 만들 수 있는 자바스크립트를 개발하게 되었습니다.

<br>

## 자바스크립트는 왜 싱글 스레드일까요?

자바스크립트가 만들어질 당시 웹 페이지의 동적인 요소는 단순했고 복잡한 멀티 스레딩이 필요하지 않았기에 단기간에 빠르게 언어를 개발할 수 있는 싱글 스레드를 채택했습니다.

이러한 싱글 스레드 모델의 채택으로 DOM 조작의 일관성과 이벤트 실행 순서를 예측할 수 있다는 장점이 있습니다.

하지만 이 모델의 주요 한계점은 복잡한 연산 시 성능 저하와 다중 코어 활용의 어려움입니다. 특히 현대 웹 애플리케이션의 복잡한 요구사항을 충족시키는 데 제약이 있습니다.

이런 한계를 극복하기 위해 자바스크립트 생태계는 비동기 프로그래밍 패턴, Promise, async/await 등을 도입했으며, Web workers를 통해 백그라운드 스레드 실행을 지원하고 있습니다.

> Web Workers는 JavaScript가 웹 페이지의 성능에 영향을 주지 않고 백그라운드에서 스크립트를 실행할 수 있게 해주는 기술입니다.

<br>

## 재귀함수의 장점과 단점은 어떤 것들이 있을까요?

재귀함수란 자기 자신을 호출하는 함수를 뜻합니다.

복잡한 알고리즘을 간결하게 표현할수 있고 복잡한 문제를 작은 문제로 분할하기 쉽다는 장점이 있지만 각 재귀 호출마다 스택 메모리를 사용하므로 메모리 사용량이 많고, 깊은 재귀는 스택 오버플로우를 일으킬 수 있다는 문제와 디버깅이 복잡할 수 있고, 종료 조건을 제대로 설정하지 않으면 무한 루프에 빠질 수 있다는 단점이 있습니다.

<br>

## 재귀 방식과 iterative 방식의 장단점은 무엇인가요?

재귀 방식은 코드가 간결하고 읽기 쉬우며 복잡한 문제를 작은 문제로 분할하기 쉽다는 장점이 있습니다. 하지만 메모리 사용량이 많고 깊은 재귀에서 스택 오버플로우 발생할 수 있고 때로는 iterative 방식보다 성능이 낮다는 단점이 있습니다.

iterative 방식은 일반적으로 메모리 사용량이 적고 스택 오버플로우 위험이 없다는 점과 실행 속도가 빠르다는 장점이 있으나 코드가 복잡해질 수 있다는 단점이 있습니다.

<br>

# React

## 제어 컴포넌트와 비제어 컴포넌트

제어 컴포넌트는 React에 의해 값이 제어되는 입력 폼 요소입니다. 리액트가 입력의 현재 값을 항상 “제어”합니다. 상태를 통해 입력값을 관리하고 setState 호출을 통해 상태를 업데이트합니다.

비제어 컴포넌트는 리액트가 입력의 값을 직접 제어하지 않습니다. ref를 사용해 필요할 때 DOM에서 값을 가져옵니다.

사용자가 입력할 때 마다 입력값의 유효성 검사가 필요한 경우 제어 컴포넌트를 사용하는 것이 권장되고, 그 외에 폼 입력 요소가 많고 실시간 유효성 검사가 필요한 경우가 아니라면 비제어 컴포넌트를 사용하는 것이 효율적일 수 있습니다.

<br>
